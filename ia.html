<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js">
</script>
<script>
const pi = Math.PI;
const tau = 2*pi;
const e = Math.E;

const expr2expression = {    // non-identity conversions from internal string
  'a' : ' atan',
  'l' : ' log',
  'h' : '\u03b8',    // theta
  'i' : '\u03c0',    // pi
  'j' : '\u03c4',    // tau
  '-' : '\u2212',    // minus
  '*' : '\u00d7',    // times
  '/' : '\u00f7',    // divide
  '^' : '\u2191',    // powup
  '\\': '\u2193',    // powdn
  '%' : ' mod '
};

var expr;          // internal string for math expression
var expression;    // display string for math expression
var parsetable;    // dictionary exprchar->buttonelement
var exprbuttons;   // keys to enter components of math expression
var vv = {};       // variable -> expression
var plottedvars = [];    // last array of variables that were plotted
var vvars = {};    // variable -> list of variables found in vv[variable]
var tvars = {};    // transitive closure of vvars

var cvs;
var ctx;

function init() {
  const W = window.innerWidth;
  expr = '';
  expression = document.getElementById('expression');
  expression.innerHTML = '';
  parsetable = {};
  exprbuttons = [];
  document.body.addEventListener('keydown',algkey);
  document.getElementById('clear').addEventListener('click',clear);
  var i;
  var b,c;
  b = document.getElementById('exprbuttons').children;
  for (i=0; i < b.length; i++) {
    if (b[i].id == 'keyboard') {
    } else if (b[i].id == 'bs') {
      b[i].addEventListener('click',bs);
    } else {
      b[i].addEventListener('click',bp);
      c = b[i].innerHTML;
      parsetable[c.length == 1 ? c : b[i].getAttribute('key')] = b[i];
      exprbuttons.push(b[i]);
    }
  }
  b = document.getElementsByClassName('exprbox');
  for (i=0; i < b.length; i++) {
    b[i].addEventListener('dragstart',dragStartHandler);
    b[i].addEventListener('drop',dropHandler);
    b[i].addEventListener('dragover',dragoverHandler);
  }  
  b = document.getElementById('exprboxes').getElementsByTagName('button');
  for (i=0; i < b.length; i++) {
    b[i].addEventListener('click',toggle);
  }
  cvs = document.getElementById('canvas');
  cvs.width = side;
  cvs.height = side;
  ctx = cvs.getContext('2d');
  ctx.lineWidth = 1;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.strokeStyle = 'black';
  parse();
  document.getElementById('bot').value = -1;
  document.getElementById('top').value = 1;
  document.getElementById('lft').value = -1;
  document.getElementById('rgt').value = 1;  
  b = document.getElementsByTagName('input');
  for (i=0; i < b.length; i++) {
    b[i].step=.125;
    b[i].addEventListener('change',updateLimits);
  }
  MathJax.startup.output.options.linebreaks.inline = false;
}

function dragStartHandler(event) {
  event.dataTransfer.setData('text',event.target.id);
}

function dragoverHandler(event) {
  event.preventDefault();
}

function dropHandler(event) {
  event.preventDefault();
  const data = event.dataTransfer.getData('text');
  var t = event.target;
  while (t.id.slice(0,7) != 'mathbox') t = t.parentNode;
  const n = t.id.slice(7);
  const m = MathJax.startup.document.getMathItemsWithin([document.getElementById(data)])[0].math;
  const x = "<p id='math" + n + "' draggable='true'>\\(" + m + "\\)</p>";
  MathJax.typesetClear([t]);
  t.innerHTML = x;
  MathJax.typeset([t]);
  if (n) {
    vv[n] = expr2js(m);
    plot();
  } else {    // need to recreate expr from TeX
    var s = m.replace(/-/g,document.getElementById('minus').innerHTML)
             .replace(/\\bmod /g,'%')
             .replace(/\\atan/g,'a')
             .replace(/\\log/g,'l')
	     .split('');
    var i;
    lastopen.length = 0;
    for (i=0; i<s.length; i++) {
      switch (s[i]) {
      case '^':
	if (s[i+1] == '{') {
	  s[i++] = expr2expression['^'];
	  s[i] = '';
	  lastopen.push(1);
	}
      case '_':
	if (s[i+1] == '{') {
	  s[++i] = '';
	  lastopen.push(2);
	}
	break;
      case '(':
	lastopen.push(0);
	break;
      case '{':
	lastopen.push(1);    // shouldn't happen
	break;
      case ')':
	lastopen.pop();
	break;
      case '}':
	if (lastopen.pop() == 2 && s[i+1] == '(') {
	  s[i] = ',';
	  s[++i] = '';
	} else {
	  s[i] = expr2expression['\\']
	}
      default :
      }
    }
    expr = s.join('');
    expression.innerHTML = expand(expr);
    document.getElementById('debug').innerHTML = expr2js(m);
    if (t.scrollWidth > t.clientWidth) t.scrollLeft = t.scrollWidth-t.clientWidth;
  }
}

function toggle(event) {
  event.preventDefault();
  var t = event.target;
  if (t.classList.contains('up')) {
    t.classList.remove('up');
    t.classList.add('down');
  } else if (t.classList.contains('down')) {
    t.classList.remove('down');
    t.classList.add('up');
  }    
  plot();
}

function algkey(event) {    // key down
  if (event.target.tagName == 'INPUT') return;
  event.preventDefault();
  const k = event.key;
  var o;
  if (k == 'Delete') {
    expr = '';
  } else if (k == 'Backspace') {
    expr = expr.slice(0,-1);
  } else if ('0' <= k && k <= '9') {
    expr += k;
  } else if ('p' <= k && k <= 'z' || k == 'a' || k == 'e') {
    o = document.getElementsByClassName('var')[0];
    if (!o.disabled) expr += k;
  } else if ('h' <= k && k <= 'j') {
    o = document.getElementsByClassName('var')[0];
    if (!o.disabled) expr += expr2expression[k];
  } else if (k == '+') {
    o = document.getElementById('plus');
    if (!o.disabled) expr += k;
  } else if (k == '-') {
    o = document.getElementById('minus');
    if (!o.disabled) expr += o.innerHTML;
  } else if (k == '.') {
    o = document.getElementById('decpt');
    if (!o.disabled) expr += k;
  } else if (k == '(') {
    o = document.getElementById('oparen');
    if (!o.disabled) expr += k;
  } else if (k == ')') {
    o = document.getElementById('cparen');
    if (!o.disabled) expr += k;
  } else if (k == '^') {
    o = document.getElementById('powup');
    if (!o.disabled) expr += o.innerHTML;
  } else if (k == '*') {
    o = document.getElementById('times');
    if (!o.disabled) expr += o.innerHTML;
  } else if (k == '/') {
    o = document.getElementById('divide');
    if (!o.disabled) expr += o.innerHTML;
  } else if (k == '%') {
    o = document.getElementById('mod');
    if (!o.disabled) expr += k;
  } else if (k == '\\') {
    o = document.getElementById('powdn');
    if (!o.disabled) expr += o.innerHTML;
  } else if (k == '!') {
    o = document.getElementById('bang');
    if (!o.disabled) expr += k;
  } else if (k == ',') {
    o = document.getElementById('comma');
    if (!o.disabled) expr += k;
  } else if (k == 'a') {
    o = document.getElementById('atan');
    if (!o.disabled) expr += k;
  } else if (k == 'l') {
    o = document.getElementById('log');
    if (!o.disabled) expr += k;
  } else if (k == '_') {
    o = document.getElementById('base');
    if (!o.disabled) expr += k;
  } else {
    return;
  }
  expression.innerHTML = expand(expr);
  parse();
}

function expand(expr) {    // expand expr for display
  var i,c,d,x=[];
  for (i=0; i < expr.length; i++) {
    c = expr[i];
    x.push((d = expr2expression[c]) ? d : c);
  }
  return x.join('');
}

function clear(event) {    // clear pressed
  expr = '';
  expression.innerHTML = '';
  parse();
}

function bs(event) {    // backspace pressed
  expr = expr.slice(0,-1);
  expression.innerHTML = expand(expr);
  parse();
}

function bp(event) {    // button pressed
  const o = event.target;
  var c = o.innerHTML;
  expr += c.length == 1 ? c : o.getAttribute('key');
  expression.innerHTML = expand(expr);
  parse();
}

var parstate;    /* 0: initial or after unary operator (can't have ^)
		    1: accumulating digits
		    2: accumulating variables
		    3: need binary argument
		    4: accumulating digits and . seen
		    5: . is only "digit"
		    6: log just happened
		    7: atan just happened
		 */
var lastopen = [];    // stack; 0:( or comma, 1:^, 2:log_, 3:atan

const closure = ')}})';    // closure for lastopen

function parse() {    // parse expression and return in math element as latex string
  /* depending on current value of expression, disable some buttons
     times, divide, and power can only follow a digit or variable
     digits cannot follow variables
     but + and - can be unary and so can follow any operations
     ) is only enabled when there is a matching ( on the same power level
     v is only enabled when the parens match within the power level
     Should we render divide as a fraction, and group multiplications
     in both the numerator and denominator, making / have lower precedence?
  */
  var i;
  var c,o;
  var s = expr;
  var m = '\\(';    // math string
  o = document.getElementById('exprdiv');
  if (o.scrollWidth > o.clientWidth) o.scrollLeft = o.scrollWidth-o.clientWidth;
  parstate = 0;
  lastopen.length = 0;
  for (i = 0; i < s.length; i++) {
    c = s[i];
    o = parsetable[c];
    switch (o.id) {
    case 'oparen' :
      lastopen.push(parstate==7 ? 3 : 0);
      parstate = 0;
      m += c;
      break;
    case 'cparen' :
      lastopen.pop();
      parstate = 2;
      m += c;
      break;
    case 'powup' :
      parstate = 0;
      lastopen.push(1);
      m += '^{'
      break;
    case 'powdn' :
      lastopen.pop();
      parstate = 2;
      m += '}';
      break;
    case 'atan' :
      parstate = 7;
      m += '\\atan';
      break;
    case 'log' :
      parstate = 6;
      m += '\\log';
      break;
    case 'base' :
      lastopen.push(2);
      parstate = 0;
      m += '_{'
      break;
    case 'comma' :
      m += lastopen[lastopen.length-1] == 2 ? '}(' : ',';
      lastopen[lastopen.length-1] = 0;
      parstate = 0;
      break;
    case 'minus' :
      c = '-';
    default :
      if (c == '%') c = '\\bmod ';
      m += c;
      if (c == '.') {
	parstate = parstate == 1 ? 4 : 5;
      } else {
	parstate = !o.classList.contains('binary') ?
	  (!o.classList.contains('op') ?
	   (!o.classList.contains('digit') ? 2 : parstate < 4 ? 1 : 4) :
	   (parstate ? 3 : 0)) : 3;
      }
    }
  }
  setkeys(parstate);
  while ((i = lastopen.pop()) != undefined) m += closure[i];
  m += '\\)';
  document.getElementById('debug').innerHTML = expr2js(m.slice(2,-2));
  MathJax.typesetClear([document.getElementById('mathbox')]);
  document.getElementById('math').innerHTML = m;
  MathJax.typeset(['#math']);
  o = document.getElementById('mathbox');
  if (o.scrollWidth > o.clientWidth) o.scrollLeft = o.scrollWidth-o.clientWidth;
}

function setkeys(state) {
  /* enable and disable keys as appropriate for the state
  */
  const last = lastopen[lastopen.length-1];
  var i;
  var o;
  switch (state) {
  case 0 :    // start of subexpression
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.classList.contains('binary') || o.id.indexOf('pow') >= 0 ||
	o.id == 'cparen' || o.id == 'bang' || o.id == 'base' || o.id == 'comma';
    }
    break;
  case 1 :    // sequence of digits seen
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.classList.contains('closer') &&
	(o.id == 'cparen' && last != 0 && last != 3 ||
	 o.id == 'powdn' && last != 1 ||
	 o.id == 'comma' && last != 2 && last != 3) || o.id =='base';
    }
    break;
  case 2 :    // variable or parenthesized expression seen
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.id == 'bang' || o.id == 'base' ||
	o.classList.contains('closer') &&
	(o.id == 'cparen' && last != 0 && last != 3 ||
	 o.id == 'powdn' && last != 1 ||
	 o.id == 'comma' && last != 2 && last != 3);
    }
    break;
  case 3 :    // need argument
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.classList.contains('closer') || o.id == 'powup' ||
	o.id == 'bang' || o.id == 'base' || o.classList.contains('binary');
    }
    break;
  case 4 :    // a decimal point has been seen
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.id == 'decpt' || o.id == 'bang' || o.id == 'base' ||
	o.classList.contains('closer') &&
	(o.id == 'cparen' && last != 0 && last != 3 ||
	 o.id == 'powdn' && last != 1 ||
	 o.id == 'comma' && last != 2 && last != 3);
    }
    break;
  case 5 :    // a lone decimal point
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled = !o.classList.contains('digit');
    }
    break;
  case 6 :    // log: only _ and ( are legal
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled = o.id != 'oparen' && o.id != 'base';
    }
    break;
  case 7 :    // atan: only ( is legal
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled = o.id != 'oparen';
    }
    break;
  default:
    throw new Error('unknown parstate '+state);
  }
}

function rational(a) {    // convert a to rational: [numerator,denominator]
  if (!Number.isFinite(a)) return [a==a && Math.sign(a) || 0,0];
  if (Number.isInteger(a)) return [a,1];
  var b = Math.abs(a);
  var x = b;
  var m0=0, m1=1, n0=1, n1=0;
  var t0,t1;
  var i, c, ix, fx;
  for (i = 64; i--;) {
    ix = Math.floor(x);
    fx = x%1;
    t0 = n0;
    t1 = n1;
    n0 = m0 + ix*n0;
    n1 = m1 + ix*n1;
    m0 = t0;
    m1 = t1;
    if (fx == 0 || n0/n1 == b) break;
    x = 1/fx;
    if (!Number.isFinite(x)) break;
  }
  return [Math.sign(a)*n0,n1];
}

function xgcd(a,b) {    // extended gcd: return [g,u,v] where g=ua+vb
  var c=1, d=0, e=0, f=1;
  var g,h;
  var q,r;
  while (b) {
    q = Math.floor(a/b);
    r = a - q*b;
    g = e;
    h = f;
    e = c-q*e;
    f = d-q*f;
    c = g;
    d = h;
    a = b;
    b = r;
  }
  return a ? a < 0 ? [-a,-c,-d] : [a,c,d] : [0,0,0];
}

function factor(n,b) {    // factor n into primes up to (but not including) b
  if (!Number.isInteger || n < 1) {
    throw new TypeError('Only positive integers can be factored');
  }
  var f = {};
  if (n == 1) return f;
  if (b <= 2) return {n:1};
  var p = 2;
  while (!(n&1)) {
    f[p] = (f[p] || 0) + 1;
    n >>= 1;
  }
  if (n == 1) return f;
  for (p = 1; (p+=2) < b; ) {
    while (!(n%p)) {
      f[p] = (f[p] || 0) + 1;
      n /= p;
    }
    if (n == 1) return f;
  }
  f[n] = 1;
  return f;
}

function atan(y,x) {
  return Math.atan2(y,x==undefined?1:x);
}

function blog(b,a) {    // log, but with args reversed
  return Math.log(a)/Math.log(b);
}

function mod(a,b) {    // mathematical mod function
  // Note: javascript % is in (-|b|,|b|)
  b = Math.abs(b);
  var f,r,s;
  var p;    // prime factors
  if (Number.isInteger(b)) {   // integer modulus: value in [0,|b|).
    if (!Number.isInteger(a) && b != 1) {
      r = rational(a);
      f = factor(r[1],b);
      var x=r[0];
      for (p in f) {
	if (p >= b) {
	  x = 0;
	  break;
	}
	s = xgcd(p,b);
	if (s[0] != 1) {
	  x = 0;
	  break;
	}
	x *= s[1]**f[p];
      }
      if (x) return mod(x,b);
    }
    r = a%b;
    return r < 0 ? r + b : Math.abs(r);    // don't want -0
  } else {                     // noninteger modulus: value in (-b/2,b/2]
    r = a%b;
    return r > b/2 ? r-b : r <= -b/2 ? r+b : r;
  }
}

function expr2js(expr) { // convert math expression to javascript expression
  /* Until converted into a string, signs, digits, and variables are accumulated
     Unary signs are combined (0 for +, 1 for -). Unary + is never output.
     Binary sign is indicated as 1 for -, 2 for +.
     Digits are accumulated as a string.
     Variables are accumulated as a list of 1-character strings, but the
     variable list also includes subexpression strings, e.g. '14**(32)'
     ( ... ) gets converted and appended to vars [with the parens included]
     ?^{ ... } gets converted and ? is replaced by ?^( ) and appended to vars
     Subexpression conversions are trigger by ')', '}', or any operator.
     unary -?^? requires parens: -(?^?)
     unary -?%? requires parens: mod(-?,?)
  */
  const p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;    // for eval test at end
  const theta=0;
  var js = '';   // output javascript expression
  var sign;      // unary sign: 0 -> +, 1 -> -
  var digits;    // string of digits
  var vars;      // sequence of variables and subexpressions with implied multiplication
  var binary;    // 0 if first sign not binary, 1 if -, 2 if +
  var i,b,c,d;
  var recur = [];       // saved variables for recursion
  function reset() {    // start of subexpression
    sign = 0;
    digits = '';
    vars = [];
    binary = 0;
  }
  function finish(op) {    // lhs completed with binary op
    if (digits.length) {
      vars.push(digits);
    }
    if (!vars.length) {
      if (op.length) {
	throw new SyntaxError('No left hand arg for '+op+' at '+i);
      }
    } else {
      if (vars[0].slice(-1)==',') {    // complete mod
	vars[0] += vars.slice(1).join('*')+')';
	vars.length = 1;
	sign = 0;
	digits = '';
	binary = 0;
      }
      if (op=='%') {            // start mod
	vars[0] = 'mod(' + (sign ? '-1*' : '') + vars.join('*') + ',';
	vars.length = 1;
	sign = 0;
	digits = '';
      } else {    // append js with unary sign and accumulated vars, followed by op
	js += (binary ? '+-'[(binary+sign)&1] : sign ? '-' : '') + 
	  ((vars.length > 1 || !binary && sign && vars[0].indexOf('**') >= 0) ? 
	   '(' + vars.join('*') + ')' : vars[0]) + op;
	reset();
      }
    }
  }
  function usign(op) {    // accumulate unary signs
    var j;         // 0 -> +, 1-> -
    var unary=0;   // for accumulating signs
    while (i < expr.length-1) {
      if ((j = '+-'.indexOf(expr[i+1])) < 0) break;
      unary ^= j;
      ++i;
    }
    if (digits.length || vars.length) {    // binary op
      finish(op);
      sign = unary;
    } else {
      sign ^= '+-'.indexOf(op) ^ unary;
    }
  }
  reset();
  for (i=0; i < expr.length; i++) {
    c = expr[i];
    switch (c) {
    case '\\':
      c = expr.slice(i+1).match(/(^\w*)\s*/);
      i += 1+c[0].length;
      switch (c[1]) {
      case 'bmod' :
	i--;
	finish('%');
	break;
      case 'log_' :
	if (digits.length) {
	  vars.push(digits);
	}
	if ((c=expr[i]) != '{') {
	  throw new SyntaxError('Improper base at '+i);
	}
	// process base (ending in })
	vars.push('blog(');
	recur.push(
	  {c:c,js:js,sign:sign,vars:vars,binary:binary});
	reset();
	break;
      case 'log' :
	if (digits.length) {
	  vars.push(digits);
	}
	if ((c=expr[i]) != '(') {
	  throw new SyntaxError('log arg must be parenthesized');
	}
	vars.push('blog(e,');
	recur.push(	  // process arg ending in )
	  {c:c,js:js,sign:sign,vars:vars,binary:binary});
	reset();
	break;
      case 'atan' :
	if ((c=expr[i]) != '(') {
	  throw new SyntaxError('Improper arg at '+i);
	}
	if (digits.length) {
	  vars.push(digits);
	}
	// first arg ends with , or only arg ends with )
	vars.push('atan(');
	recur.push(
	    {c:c,js:js,sign:sign,vars:vars,binary:binary});
	reset();
	break;
      default:
	throw new SyntaxError('Unknown token at '+i);
      }
      break;
    case ',' :    // first arg of atan
      if (!recur.length) {
	throw new SyntaxError('Unexpected comma at position '+i);
      }
      finish(',');
      b = recur[recur.length-1];
      b.vars[b.vars.length-1] += js;
      js = '';
      reset();
      break;
    case '^' :
      if ((c=expr[++i]) != '{') {
	throw new SyntaxError('Improper exponent at '+i);
      }
      if (digits.length) {
	vars.push(digits);
      }
      if (vars.length) {
	vars.push(vars.pop() + '**(');
      } else {
	throw new SyntaxError('Exponent without base at position '+i);
      }
      recur.push(
	{c:c,js:js,sign:sign,vars:vars,binary:binary});
      js = '';
      reset();
      break;
    case '(' :
      if (digits.length) {
	vars.push(digits);
      }
      recur.push(
	{c:c,js:js,sign:sign,vars:vars,binary:binary});
      js = c;
      reset();
      break;
    case '}' :    // terminates ^ or _
    case ')' :    // terminates (
      if (!recur.length) {
	throw new SyntaxError('Unmatched '+c+' at position '+i);
      }
      b = recur[recur.length-1];
      if (b.vars.length && b.vars[b.vars.length-1] == 'blog(') {
	if ((c=expr[++i]) != '(') {
	  throw new SyntaxError('log arg must be parenthesized');
	}
	b.c = c;
	finish(',');
	b.vars[b.vars.length-1] += js;
	js = '';
	reset();
	break;
      }
      finish(')');
      b = recur.pop();
      vars = b.vars;
      binary = b.binary;
      if (b.vars.length &&
	  (d = b.vars[b.vars.length-1].slice(-1)) == ',' || d == '(') {
	b.vars[b.vars.length-1] += js;
      } else {
	vars.push(js);
      }
      digits = '';
      sign = b.sign;
      js = b.js;
      b = b.c;
      if (!(b == '(' && c == ')' || b == '{' && c == '}')) {
	throw new SyntaxError('Unmatched '+c+' at position '+i);
      }
      break;
    case '+' :
    case '-' :
      usign(c);
      break;
    case '\u00d7' :    //times
      finish('*');
      break;
    case '\u00f7' :    //divide
      finish('/');
      break;
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      digits += c;
      break;
    case '.':
      if (digits.indexOf('.') >= 0) {
	throw new SyntaxError('Multiple decimal points');
      }
      digits += c;
      break;
    case '!':
      if (!digits.length || digits.indexOf('.') >= 0) {
	throw new SyntaxError('Illegal factorial');
      }
      vars.push('factorial('+digits+')');
      digits = '';
      break;
    case '\u03b8':
      c = 'theta';
    case '\u03c0':
      if (c.length == 1) c = 'pi';
    case '\u03c4':
      if (c.length == 1) c = 'tau';
    case 'e':
    case 'p': case 'q': case 'r': case 's': case 't':
    case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':
      if (digits.length) {
	vars.push(digits)
	digits = '';
      }
      vars.push(c);
      break;
    default :
      throw new SyntaxError('Unrecognized symbol');
    }
  }
  if (recur.length) {
    throw new SyntaxError('Premature termination of expression');
  }
  finish('');
  eval(js);    // might get syntax error
  return js;
}

function variables(expr) {    // return frequency of variables in expression
  var d = {};
  var i,c;
  const m = expr.match(/\w+/g);
  for (i in m) {
    c = m[i];
    if (c.length == 1 && 'p'<=c && c<='z' || c=='theta') {
      if (c in d) {
	d[c] += 1;
      } else {
	d[c] = 1;
      }
    }
  }
  return d;     
}

function length(o) {    // return length of object
  return Object.keys(o).length;
}

function fulleval(vin,obj) {    // evaluate variable v using dictionary o
  if (tvars[vin][vin] != undefined) {
    throw new Error('self-referential variable '+vin);
  }
  var win;
  for (win in vvars[vin]) {
    if (obj[win] == undefined) fulleval(win,obj);
  }
  for (win in obj) {
    eval('var '+win+'=obj[win];');
  }
  return (obj[vin]=eval(vv[vin]));
}

function updateLimits(event) {
  addplot(plottedvars);  
}

function plot() {    // plot expressions
  // automatically compute limits ?
  const b = document.getElementById('exprboxes').getElementsByClassName('down');
  var i;
  var vars = [];
  for (i=0; i<b.length; i++) {
    vars.push(b[i].previousElementSibling.id.slice(-1));
  }
  addplot(vars);
}

const side = 513;

function addplot(vars) {    // plot expressions with current limits
  plottedvars = vars.slice();
  var changed = false;
  const x0 = document.getElementById('lft').valueAsNumber;
  const x1 = document.getElementById('rgt').valueAsNumber;  
  const y0 = document.getElementById('bot').valueAsNumber;
  const y1 = document.getElementById('top').valueAsNumber;  
  var n,i,j,k;
  var hi,hj,oi,oj;    // old values to decide between moveTo and lineTo
  var d;    // distance between old and new points
  var v;
  var x;
  var y;
  var r,theta;
  var l;
  var changed = true;
  if (!(x0<x1 && y0<y1)) throw new Error('Low Limits Must Be Less Than High Limits');
  vvars = {};
  for (v in vv) {
    vvars[v] = variables(vv[v]);
    tvars[v] = Object.assign({},vvars[v]);
  }
  while (changed) {
    changed = false;
    for (v in vvars) {
      l = length(tvars[v]);
      for (w in tvars[v]) {
	Object.assign(tvars[v],tvars[w]);
      }
      changed |= l != length(tvars[v]);
    }
  }
  ctx.clearRect(0,0,side,side);
  ctx.strokeStyle='gray';
  if (x0 < 0 && 0 < x1) {
    ctx.beginPath();
    ctx.moveTo((1-side)*x0/(x1-x0),0);
    ctx.lineTo((1-side)*x0/(x1-x0),side);
    ctx.stroke();
  }
  if (y0 < 0 && 0 < y1) {
    ctx.beginPath();
    ctx.moveTo(0,(side-1)*y1/(y1-y0));
    ctx.lineTo(side,(side-1)*y1/(y1-y0));
    ctx.stroke();
  }
  ctx.strokeStyle='black';
  for (n in vars) {
    ctx.beginPath();
    if (tvars[vars[n]]['x']) {
      for (i = 0; i <= side-1; i += .5) {
	x = x0 + i*(x1-x0)/(side-1);
	y = fulleval(vars[n],{x:x});
	j = (side-1)*(y1-y)/(y1-y0);
	if (!Number.isInteger(i)) {
	  hj = j;
	} else {
	  if (!i) {
	    ctx.moveTo(i,j);
	  } else {
	    d = .875*Math.abs(j-oj);
	    d < 2 || Math.abs(hj-oj) < d && Math.abs(j-hj) < d ?
	      ctx.lineTo(i,j) : ctx.moveTo(i,j);
	  }
	  oj = j;
	}
      }
    } else if (tvars[vars[n]]['y']) {
      for (j = 0; j <= side-1; j += .5) {
	y = y1 - j*(y1-y0)/(side-1);
	x = fulleval(vars[n],{y:y});
	i = (side-1)*(x-x0)/(x1-x0);
	if (!Number.isInteger(j)) {
	  hi = i;
	} else {
	  if (!j) {
	    ctx.moveTo(i,j);
	  } else {
	    d = .875*Math.abs(i-oi);
	    d < 2 || Math.abs(hi-oi) < d && Math.abs(i-hi) < d ?
	      ctx.lineTo(i,j) : ctx.moveTo(i,j);
	  }
	  oi = i;
	}
      }
    } else if (tvars[vars[n]]['theta']) {
      for (k = 0; k <= 360; k += .5) {
	theta = pi*k/180;
	r = fulleval(vars[n],{theta:theta});
	x = r*Math.cos(theta);
	y = r*Math.sin(theta);
	i = (side-1)*(x-x0)/(x1-x0);
	j = (side-1)*(y1-y)/(y1-y0);
	if (!Number.isInteger(k)) {
	  hi = i;
	  hj = j;
	} else {
	  if (!k) {
	    ctx.moveTo(i,j);
	  } else {
	    d = .75*((i-oi)**2 + (j-oj)**2);
	    d < 4 || (hi-oi)**2+(hj-oj)**2 < d && (i-hi)**2+(j-hj)**2 < d ?
	      ctx.lineTo(i,j) : ctx.moveTo(i,j);
	  }
	  oi = i;
	  oj = j;
	}
      }
    }
    ctx.stroke();
  }
}

function showhidenext(o) {
  if (o.innerHTML=='Hide') {
    o.nextElementSibling.style.display='none';
    o.innerHTML = 'Show';
  } else {
    o.nextElementSibling.style.display='inline';
    o.innerHTML = 'Hide';
  }
}

function showhelp(s) {
  var o = document.getElementById(s);
  o.style.display='block';
}		      

function showpopup(o,s) {
  var b = document.body.getClientRects()[0];
  var r = o.parentNode.getClientRects()[0];
  o = document.getElementById(s);
  o.style.display='block';
  var q = o.getClientRects()[0];
  o.style.position = 'absolute';
  o.style.left = (r.width-q.width)/2+'px';
  o.style.top = (r.top+r.bottom-q.height)/2-b.top+'px';
}

function factorial(n) {
  if (n != Math.floor(n) || n < 0) {
    throw new RangeError('arg must be nonnegative integer');
  }
  if (n > 170) return Infinity;
  var x = 1;
  while (n) x*= n--;
  return x;
}		      

/* thoughts:
   Is there a way to do log?
   Graph of variable dependencies (must be tree ...
   ...  unless we want to solve simultaneous equations)
*/
/* idea for new scheme:
   boxes for constants, variables, numbers, operations; arrows for interaction
   ... converted to math expressions
   always one output, but possible multiple inputs, e.g. atan, b^x, log_b x
   ... the last two defaulting b to e
   ... log without paren terminates with any operator except unary +- or ^
   ... should we allow log^ ? probably not
   ... Sum and Product ?
*/
</script>
<style>
.invisible {display:none}
#debugger {
  font-size:1em;
}
#debug {
  display:none;
}
button {
  margin:2px;
  font-size:18px;
}    
#mathbox {
  margin-bottom:2px;
}
#bs {margin-left:32px;}
#expression {display:inline;}
#exprdiv {
  overflow:hidden;
  white-space:nowrap;
  width:512px;
}
.var {
  font-family:serif;
  font-style:italic;
}
.varlabel {
  font-family:serif;
  font-style:italic;
  text-align:center;
  margin:0;
}
.popup {
  background-color:white;
  display:none;
  z-index:1;
  position:absolute;
  top:0;
  left:0;
  padding:6px;
  margin:6px;
  border:1px solid black;
  max-width:inherit;
}
#topbox {
  display:grid;
  grid-template-columns: 460px 60px;
  align-items:center;
}
#exprboxes {
  display:grid;
  grid-template-columns: 20px 440px 60px;
  row-gap:2px;
  align-items:center;
  margin-top:2px;
}
#exprboxes button {
  margin-left:4px;
  width:50px;
  font-size:12px;
}
.exprbox {
  display:flex;
  justify-content:center;
  align-items:center;
  width:440px;
  height:32px;
  border:1px solid black;
  padding:0;
  margin:0;
  text-align:center;
  overflow-x:auto;
  overflow-y:hidden;
}
.up {
  background-color:white;  
}
.down {
  background-color:pink;
}
#mathdiv {
  margin-top:10px;
  float:left;
}
#keyboard {
  display:inline;
  margin-left:20px;
  text-decoration:underline;
  cursor:context-menu;
}
#plot {
  float:left;
  display:grid;
  grid-template-columns: 20px 100px 313px 100px;
  grid-template-rows: 100px 313px 100px 20px;
  margin-top:10px;
  margin-left:10px;
}
input[type=number]::-webkit-outer-spin-button,
input[type=number]::-webkit-inner-spin-button {
  -webkit-appearance:none;
  margin:0;
}
input[type=number] {
  width:100px;
  height:20px;
  margin:0;
  box-sizing:border-box;
  -moz-appearance:textfield;
  appearance:textfield;
}
#top {
  grid-column-start:1;
  grid-row-start:1;
  transform:rotate(-90deg);
  transform-origin:50px 50px;
  text-align:right;
}
#bot {
  grid-column-start:1;
  grid-row-start:3;
  transform:rotate(-90deg);
  transform-origin:50px 50px;
  text-align:left;
}
#lft {
  grid-column-start:2;
  grid-row-start:4;
  text-align:left;
}
#rgt {
  grid-column-start:4;
  grid-row-start:4;
  text-align:right;
}
#canvas {
  grid-column-start:2;
  grid-column-end:span 3;
  grid-row-start:1;
  grid-row-end:span 3;
  width:513px;
  height:513px;
}
#x {
  grid-row-start:4;
  grid-column-start:3;
}
#y {
  grid-row-start:2;
  grid-column-start:1;
  align-self:center;
}
p.top {
  position:absolute;
  left:0;top:0;
  text-align:left;
  font-size:.75em;
  margin:0;
}
#helper {
  text-decoration:underline;
  font-size:11px;
  cursor:context-menu;
  margin-left:60px;
}
#help {
  position:absolute;
  left:270px;top:0;
  width:750px;
}
h2 {
  text-align:center;
  margin-top:0;
}
ul {
  padding-left:1em;
  padding-top:0;
}
li {
  text-indent:.25em;
}
table {
  border-collapse:collapse;
  margin:0 auto;
}
td {
  text-align:center;
  width:30px;
}
</style>
</head>
<body onload='init()'>
<p class='top'>
  <a href='fib.html'>Fi &amp; Lu</a>&nbsp;
  <a href='area.html'>Area</a>&nbsp;
  <a href='algebra.html'>Algebra</a>
  <a href='trig.html'>Trigonometry</a>&nbsp;
  <a href='func.html'>Functions</a>&nbsp;
  <a href='complex.html'>Complex Numbers</a>&nbsp;
  <a href='calc.html'>Calculus</a>
  <span id='helper' onclick="showhelp('help')">HELP</span>
</p>
<div id='mathdiv'>
<div id='topbox'>
<div id='mathbox' class='exprbox' title='math expression, draggable'><p id='math' draggable='true'></p></div>
<button id='clear'>Clear</button>
</div>
<div id='exprdiv'><p id='expression' contenteditable='plaintext-only'></p><br></div>
<div id='exprbuttons' tabindex='0'>
<button class='var' title='theta (h)' key='h'>&theta;</button>
<button class='var'>p</button>
<button class='var'>q</button>
<button class='var'>r</button>
<button class='var'>s</button>
<button class='var'>t</button>
<button class='var'>u</button>
<button class='var'>v</button>
<button class='var'>w</button>
<button class='var'>x</button>
<button class='var'>y</button>
<button class='var'>z</button>
<button id='bs'>Backspace</button>
<br>
<button class='var'>e</button>
<button class='var' title='pi (i)' key='i'>&pi;</button>
<button class='var' title='tau=2pi (j)' key='j'>&tau;</button>
<button class='digit'>0</button>
<button class='digit'>1</button>
<button class='digit'>2</button>
<button class='digit'>3</button>
<button class='digit'>4</button>
<button class='digit'>5</button>
<button class='digit'>6</button>
<button class='digit'>7</button>
<button class='digit'>8</button>
<button class='digit'>9</button>
<button id='decpt'>.</button>
<button id='bang' title='factorial'>!</button>
<br>
<button id='plus' class='op' title='plus (+)' key='+'>+</button>
<button id='minus' class='op' title='minus (-)' key='-'>&minus;</button>
<button id='times' class='op binary' title='times (*)' key='*'>&times;</button>
<button id='divide' class='op binary' title='divide (/)' key='/'>&divide;</button>
<button id='mod' class='op binary' title='modulo (%)' key='%'>mod</button>
<button id='powup' class='op' title='exponentiate (^)' key='^'>&uparrow;</button>
<button id='powdn' class='op closer' title='end exponent (\)' key='\\'>&downarrow;</button>
<button id='oparen' class='op' key='('>(</button>
<button id='comma' class='op closer' title='end base or first arg' key=','>,</button>
<button id='cparen' class='op closer' key=')'>)</button>
<button id='log' class='op' title='logarithm (l), default base = e' key='l'>log</button>
<button id='base' class='op' title='base of log, terminated with comma' key='_'>_</button>
<button id='atan' class='op' title='arctangent (a), 1 or 2 args' key='a'>atan</button>
</div>
<div id='exprboxes'>
<p class='varlabel'>p</p><div id='mathboxp' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>q</p><div id='mathboxq' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>r</p><div id='mathboxr' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>s</p><div id='mathboxs' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>t</p><div id='mathboxt' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>u</p><div id='mathboxu' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>v</p><div id='mathboxv' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>w</p><div id='mathboxw' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>x</p><div id='mathboxx' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>y</p><div id='mathboxy' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>z</p><div id='mathboxz' class='exprbox'></div><button class='up'>PLOT</button>
</div>
<button id='debugger' onclick='showhidenext(this)' title='show/hide javascript code for current math expression'>Show</button>
<p id='debug'></p>  
<p class='invisible'>\(\DeclareMathOperator{\atan}{atan}\)</p>
</div>
<!--Plotting
    We have a canvas for the plot
    To the left we have two input elements for upper and lower ordinate limits
    On the top we have two input elements for lower and upper abscissa limits
    The limits can be auto-set based on what is being plotted?
-->
<div id='plot'>
  <input id='top' class='lim' type='number'></input>
  <p id='y' class='varlabel'>y</p>
  <input id='bot' class='lim' type='number'></input>
  <canvas id='canvas'></canvas>
  <input id='lft' class='lim' type='number'></input>
  <p id='x' class='varlabel'>x</p>
  <input id='rgt' class='lim' type='number'></input>
  </div>
</div>
<div id='help' class='popup' onclick='this.style.display="none";'>
<h2>Entering and plotting mathematical expressions</h2>
<p>Use the buttons and/or your keyboard to enter mathematical expressions. Special keyboard equivalents:</p>
<table><tbody><tr><td>%</td><td>a</td><td>l</td><td>h</td><td>i</td><td>j</td><td>-</td><td>*</td><td>/</td><td>^</td><td>\</td></tr>
<td>mod</td><td>atan</td><td>log</td><td>&#x03b8;</td><td>&#x03c0;</td><td>&#x03c4;</td><td>&#x2212;</td><td>&#x00d7;</td><td>&#x00f7;</td><td>&#x2191;</td><td>&#x2193;</td></tr></tbody></table>
<p>Buttons that are grayed out, and their keyboard equivalents, are not valid and are ignored. Mathematical expressions can be dragged between boxes. Variables are defined by the mathematical expressions in their correspondingly labeled boxes.</p>
<p>Depressing a PLOT button plots the corresponding mathematical expression:</p>
<ul>
<li>If the expression ultimately evaluates with a free variable \(x\), \(y=f(x)\) is plotted.</li>
<li>If the expression ultimately evaluates with a free variable \(y\), \(x=f(y)\) is plotted.</li>
<li>If the expression ultimately evaluates with a free variable \(\theta\), \(r=f(\theta)\) is plotted.</li>
<li>To plot a constant function, use an expression with the free variable multiplied by 0.</li>
</ul>
<p>The \(x\) and \(y\) limits of the plot are determined by the bottom and left input boxes, respectively.</p>
<p>Here&rsquo;s an example to try:</p>
<ul>
<li>Enter \(1-p^2&divide;2+p^4&divide;4!-p^6&divide;6!+p^8&divide;8!-p^{10}&divide;10!\) and drag it to box \(q\). (Remember, use the &uparrow; button or the ^ key to exponentiate, and the &downarrow; button or \\ key to end the exponent.)</li>
<li>Clear, then enter \(t\bmod\tau\) and drag it to box \(p\). (Remember, use the mod button or % key for mod, the \(\tau\) button or j key for \(\tau\).)</li>
<li>Finally, Clear, then enter \(\tau x\) and drag it to box \(t\) and click PLOT at box \(q\).</li>
<li>After observing the result, Clear, then enter \(5\theta\) and drag it to box \(t\).</li>
</ul>
<p>This should give you a flavor of what can be done. <b>Click to hide this popup.</b></p>
</div>
</body>
</html>
<!--We enter mathematical expressions by clicking on components
    Simultaneously we parse the expression and keep the result separately
    We may need to reparse when we delete (using backspace or delete key)
    We can keep multiple expressions in an array, displaying all of them
    To plot expressions we may color code so more than one can appear together
    Plot may compute range and domain, or user may adjust with cursor or other command
    Current expression is selected by cursor for input or editing
    ) closes (, provided it's on the same exponent level
    v closes ^, provided there are no unclosed (s
    Only legitimate continuations of expression can be selected (others are grayed out)
    Selections:
    operators: + - x / mod ^ v ( ) (square?root??)
    variables: r s t u v w x y z (concatenation is multiplication)
    constants: 0 1 2 3 4 5 6 7 8 9 (concatenation is concatenation) !

    additional operators: log_b x, atan(y,x)
      atan first arg can be terminated with , or ). If ), second arg is 1.
    allow restricted mode where some operations/variables don't appear?

    commands: new? plot?     
    = ?
    apply op arg to both sides ?
    apply "first" operation (possibly of given kind?)
    keep stack of operations so can undo
    can we color operations that are doable?
    for polynomials (in one or more variables), gather?
    apply commute, distribute ?
-->
