<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<script>
MathJax = {
  loader: {
    load: ['[tex]/mathtools']
  },
  tex: {
    packages: {'[+]':['mathtools']}
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js">
</script>
<script>
const pi = Math.PI;
const tau = 2*pi;
const e = Math.E;
Math.sgn = Math.sign;

const symbol = /\\[A-Za-z]+[A-Za-z0-9]*/;
const number = /(\d+\.?\d*|\d*\.?\d+)/;
const operator = /[-+/*^_!\u00d7\u00f7]/;
const paren = /[\[\]\(\)\{\}]/;
const variable = /[A-Za-z\u0391-\u03a9\u03b1-\u03c9]/;    //Roman & Greek
const constant = /[e\u03c0\u03c4]/;    // e, pi, tau

const token = new RegExp([symbol,number,operator,paren,variable].map(
  function(r){return r.source;}).join('|'),'g');

function tokenize(m) {
  /* given latex expression, return list of tokens...
  *  tokens are names starting with \  or
  *  single character variables  or
  *  numbers (string of digits with optional .) or
  *  operators: +-*^/_|&!  or
  *  parens {}()[] 
  */
  return m.match(token);
}

const expr2expression = {    // non-identity conversions from internal string
  'A' : ' atanh',
  'B' : ' sinh',
  'C' : ' cosh',
  'D' : ' tanh',
  'E' : ' exp',
  'F' : ' asinh',
  'G' : ' acosh',
  'S' : ' sgn',
  'V' : ' abs',
  'a' : ' atan',
  'b' : ' sin',
  'c' : ' cos',
  'd' : ' tan',
  'f' : ' asin',
  'g' : ' acos',
  'l' : ' log',
  'h' : '\u03b8',    // theta
  'i' : '\u03c0',    // pi
  'j' : '\u03c4',    // tau
  '-' : '\u2212',    // minus
  '*' : '\u00d7',    // times
  '/' : '\u00f7',    // divide
  '^' : '\u2191',    // powup
  '\\': '\u2193',    // powdn
  '_': '_(',         // base
  '%' : ' mod '
};

var expr;          // internal array for math expression
var expression;    // display string for math expression
var parsetable;    // dictionary exprchar->buttonelement
var exprbuttons;   // keys to enter components of math expression
var vv = {};       // variable -> expression
var plottedvars = [];    // last array of variables that were plotted
var vvars = {};    // variable -> list of variables found in vv[variable]
var tvars = {};    // transitive closure of vvars

var cvs;
var ctx;

function init() {
  const W = window.innerWidth;
  expr = [];
  expression = document.getElementById('expression');
  expression.innerHTML = '';
  parsetable = {};
  exprbuttons = [];
  document.body.addEventListener('paste',paste);
  document.body.addEventListener('keydown',algkey);
  document.getElementById('clear').addEventListener('click',clear);
  var i;
  var b,c;
  b = document.getElementById('exprbuttons').children;
  for (i=0; i < b.length; i++) {
    if (b[i].id == 'keyboard') {
    } else if (b[i].id == 'bs') {
      b[i].addEventListener('click',bs);
    } else {
      b[i].addEventListener('click',bp);
      c = b[i].innerHTML;
      parsetable[c.length == 1 ? c : b[i].getAttribute('key')] = b[i];
      exprbuttons.push(b[i]);
    }
  }
  b = document.getElementsByClassName('exprbox');
  for (i=0; i < b.length; i++) {
    b[i].addEventListener('dragstart',dragStartHandler);
    b[i].addEventListener('drop',dropHandler);
    b[i].addEventListener('dragover',dragoverHandler);
  }  
  b = document.getElementById('exprboxes').getElementsByTagName('button');
  for (i=0; i < b.length; i++) {
    b[i].addEventListener('click',toggle);
  }
  cvs = document.getElementById('canvas');
  cvs.width = side;
  cvs.height = side;
  ctx = cvs.getContext('2d');
  ctx.lineWidth = 1;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.strokeStyle = 'black';
  parse();
  document.getElementById('bot').value = -1;
  document.getElementById('top').value = 1;
  document.getElementById('lft').value = -1;
  document.getElementById('rgt').value = 1;  
  b = document.getElementsByTagName('input');
  for (i=0; i < b.length; i++) {
    b[i].step=.125;
    b[i].addEventListener('change',updateLimits);
  }
  MathJax.startup.output.options.linebreaks.inline = false;
  initGamma(17);    // seems to produce best precision
}

function dragStartHandler(event) {
  event.dataTransfer.setData('text',event.target.id);
}

function dragoverHandler(event) {
  event.preventDefault();
}

function dropHandler(event) {
  event.preventDefault();
  const data = event.dataTransfer.getData('text');
  var t = event.target;
  while (t.id.slice(0,7) != 'mathbox') t = t.parentNode;
  const n = t.id.slice(7);
  const s = document.getElementById(data);
  const m = MathJax.startup.document.getMathItemsWithin([s])[0].math;
  if (data == 'math') {
    clear();
  } else {
    MathJax.typesetClear([s]);
    s.innerHTML = '';
  }
  drop(m,n);
}

function drop(m,n) {
  const t = document.getElementById('mathbox'+n);
  const x = "<p id='math" + n + "' draggable='true'>\\(" + m + "\\)</p>";
  MathJax.typesetClear([t]);
  t.innerHTML = x;
  MathJax.typeset([t]);
  if (n) {
    vv[n] = expr2js(m);
    plot();
  } else {    // need to recreate expr from TeX
    m = m.replace(/-/g,document.getElementById('minus').innerHTML)
         .replace(/\\theta/g,'\u03b8')
         .replace(/\\pi/g,'\u03c0')
         .replace(/\\tau/g,'\u03c4')
         .replace(/\\bmod/g,'%')
         .replace(/\\atan/g,'a')
         .replace(/\\log/g,'l')
	 .replace(/\\sgn\(/g,'S(')
	 .replace(/\\abs/g,'V')
	 .replace(/\\sin\(/g,'b(')
	 .replace(/\\cos\(/g,'c(')
	 .replace(/\\tan\(/g,'d(')
	 .replace(/\\asin\(/g,'f(')
	 .replace(/\\acos\(/g,'c(')
	 .replace(/\\atanh\(/g,'A(')
	 .replace(/\\sinh\(/g,'B(')
	 .replace(/\\cosh\(/g,'C(')
	 .replace(/\\tanh\(/g,'D(')
	 .replace(/\\exp\(/g,'E(')
	 .replace(/\\asinh\(/g,'F(')
	 .replace(/\\acosh\(/g,'G(')
	 .split('');
    var i;
    var c;
    lastopen.length = 0;
    for (i=0; i<m.length; i++) {
      switch (m[i]) {
      case '^':
	if (m[i+1] == '{') {
	  m[i++] = expr2expression['^'];
	  m[i] = '';
	  lastopen.push(1);
	}
      case '_':
	if (m[i+1] == '{') {
	  m[++i] = '';
	  lastopen.push(2);
	}
	break;
      case '(':
	lastopen.push(0);
	break;
      case '{':
	lastopen.push(0);
	m[i] = '(';
	break;
      case ')':
	lastopen.pop();
	break;
      case '}':
	c = lastopen.pop();
	if (c == 2 && m[i+1] == '(') {
	  m[i] = ',';
	  m[++i] = '';
	} else if (c == 1) {
	  m[i] = expr2expression['\\']
	} else {
	  m[i] = ')';
	}
      default :
      }
    }
    expr = [];
    for (i=0; i< m.length; i++) {
      if (c = m[i]) expr.push(c);
    }
    expression.innerHTML = expand(expr);
    parse();
  }
}

function toggle(event) {
  event.preventDefault();
  var t = event.target;
  if (t.classList.contains('up')) {
    t.classList.remove('up');
    t.classList.add('down');
  } else if (t.classList.contains('down')) {
    t.classList.remove('down');
    t.classList.add('up');
  }    
  plot();
}

function enabled(o) {
  return (!o.disabled && o.offsetWidth);
}

function copyandpaste(event) {
  // from a selected math expression
  event.stopPropagation();
  drop(MathJax.startup.document.getMathItemsWithin([event.target])[0].math,'');
}

function paste(event) {
  // from key-sequence text
  if (event.target.tagName == 'INPUT') return;
  const text = event.clipboardData.getData('Text/plain');
  event.preventDefault();
  clear();
  for (i = 0; i < text.length; i++) {
    try {
      dokey(text[i]);
    } catch(error) {
    }
  }
}

function algkey(event) {    // key down
  if (event.target.tagName == 'INPUT') return;
  if (event.ctrlKey || event.metaKey) return;
  event.preventDefault();
  dokey(event.key);
}

function dokey(k) {
  var o;
  if (k.length > 1) {
    if (k == 'Delete') {
      expr = [];
    } else if (k == 'Backspace') {
      expr.pop();
    }
  } else if ('0' <= k && k <= '9') {
    expr.push(k);
  } else if ('ehijpqrstuvwxyz'.indexOf(k) >= 0) {
    o = document.getElementsByClassName('var')[0];
    if (enabled(o)) expr.push(expr2expression[k] || k);
  } else if ('abcdfglABCDEFGSV'.indexOf(k) >= 0) {
    o = document.getElementById(expr2expression[k].trim());
    if (enabled(o)) expr.push(k);
  } else if (k == '+') {
    o = document.getElementById('plus');
    if (enabled(o)) expr.push(k);
  } else if (k == '-') {
    o = document.getElementById('minus');
    if (enabled(o)) expr.push(o.innerHTML);
  } else if (k == '.') {
    o = document.getElementById('decpt');
    if (enabled(o)) expr.push(k);
  } else if (k == '(') {
    o = document.getElementById('oparen');
    if (enabled(o)) expr.push(k);
  } else if (k == ')') {
    o = document.getElementById('cparen');
    if (enabled(o)) expr.push(k);
  } else if (k == '^') {
    o = document.getElementById('powup');
    if (enabled(o)) expr.push(o.innerHTML);
  } else if (k == '*') {
    o = document.getElementById('times');
    if (enabled(o)) expr.push(o.innerHTML);
  } else if (k == '/') {
    o = document.getElementById('divide');
    if (enabled(o)) expr.push(o.innerHTML);
  } else if (k == '%') {
    o = document.getElementById('mod');
    if (enabled(o)) expr.push(k);
  } else if (k == '\\') {
    o = document.getElementById('powdn');
    if (enabled(o)) expr.push(o.innerHTML);
  } else if (k == '!') {
    o = document.getElementById('bang');
    if (enabled(o)) expr.push(k);
  } else if (k == ',') {
    o = document.getElementById('comma');
    if (enabled(o)) expr.push(k);
  } else if (k == '_') {
    o = document.getElementById('base');
    if (enabled(o)) expr.push(k);
  }
  expression.innerHTML = expand(expr);
  parse();
}

function expand(expr) {    // expand expr for display
  var i,c,x=[];
  for (i=0; i < expr.length; i++) {
    c = expr[i];
    x.push(expr2expression[c] || c);
  }
  return x.join('');
}

function clear(event) {    // clear pressed
  expr = [];
  expression.innerHTML = '';
  parse();
}

function bs(event) {    // backspace pressed
  expr.pop();
  expression.innerHTML = expand(expr);
  parse();
}

function bp(event) {    // button pressed
  const o = event.target;
  var c = o.innerHTML;
  expr.push(c.length == 1 ? c : o.getAttribute('key'));
  expression.innerHTML = expand(expr);
  parse();
}

var parstate;    /* 0: initial or after unary operator (can't have ^)
		    1: accumulating digits
		    2: accumulating variables
		    3: need binary argument
		    4: accumulating digits and . seen
		    5: . is only "digit"
		    6: log just happened
		    7: atan or other fcn just happened
		    8: 1-arg fcn just happened
		    9: 1-arg macro taking {}
		 */
var lastopen = [];    // stack; 0:( or comma, 1:^, 2:log_, 3:atan, 4:1-arg macro

const closure = ')}})}';    // closure for lastopen

function parse() {    // parse expression and return in math element as latex string
  /* depending on current value of expression, disable some buttons
     times, divide, and power can only follow a digit or variable
     digits cannot follow variables
     but + and - can be unary and so can follow any operations
     ) is only enabled when there is a matching ( on the same power level
     v is only enabled when the parens match within the power level
     Should we render divide as a fraction, and group multiplications
     in both the numerator and denominator, making / have lower precedence?
  */
  var i;
  var c,o;
  var s = expr;
  var m = '\\(';    // math string
  o = document.getElementById('exprdiv');
  if (o.scrollWidth > o.clientWidth) o.scrollLeft = o.scrollWidth-o.clientWidth;
  parstate = 0;
  lastopen.length = 0;
  for (i = 0; i < s.length; i++) {
    c = s[i];
    o = parsetable[c];
    if (!o) continue;
    switch (o.id) {
    case 'oparen' :
      if (parstate == 9) {
	c = '{';
	lastopen.push(4);
      } else {
	lastopen.push(parstate == 7 ? 3 : 0);
      }
      parstate = 0;
      m += c;
      break;
    case 'cparen' :
      if (lastopen.pop() == 4) c = '}';
      parstate = 2;
      m += c;
      break;
    case 'powup' :
      parstate = 0;
      lastopen.push(1);
      m += '^{'
      break;
    case 'powdn' :
      lastopen.pop();
      parstate = 2;
      m += '}';
      break;
    case 'atan' :
      parstate = 7;
      m += '\\'+o.id;
      break;
    case 'abs' :
      parstate = 9;
      m += '\\'+o.id;
      break;
    case 'sgn' :
    case 'exp' :
    case 'sin' :
    case 'cos' :
    case 'tan' :
    case 'asin' :
    case 'acos' :
    case 'sinh' :
    case 'cosh' :
    case 'tanh' :
    case 'asinh' :
    case 'acosh' :
    case 'atanh' :
      parstate = 8;
      m += '\\'+o.id;
      break;
    case 'log' :
      parstate = 6;
      m += '\\log';
      break;
    case 'base' :
      lastopen.push(2);
      parstate = 0;
      m += '_{'
      break;
    case 'comma' :
      m += lastopen[lastopen.length-1] == 2 ? '}(' : ',';
      lastopen[lastopen.length-1] = 0;
      parstate = 0;
      break;
    case 'minus' :
      c = '-';
    default :
      if (c == '%') c = '\\bmod ';
      m += c;
      if (c == '.') {
	parstate = parstate == 1 ? 4 : 5;
      } else {
	parstate = !o.classList.contains('binary') ?
	  (!o.classList.contains('op') ?
	   (!o.classList.contains('digit') ? 2 : parstate < 4 ? 1 : 4) :
	   (parstate ? 3 : 0)) : 3;
      }
    }
  }
  setkeys(parstate);
  while ((i = lastopen.pop()) != undefined) m += closure[i];
  m += '\\)';
  document.getElementById('debug').innerHTML = expr2js(m.slice(2,-2));
  MathJax.typesetClear([document.getElementById('mathbox')]);
  document.getElementById('math').innerHTML = m;
  MathJax.typeset(['#math']);
  o = document.getElementById('mathbox');
  if (o.scrollWidth > o.clientWidth) o.scrollLeft = o.scrollWidth-o.clientWidth;
}

function setkeys(state) {
  /* enable and disable keys as appropriate for the state
  */
  const last = lastopen[lastopen.length-1];
  var i;
  var o;
  switch (state) {
  case 0 :    // start of subexpression
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.classList.contains('binary') || o.id.indexOf('pow') >= 0 ||
	o.id == 'cparen' || o.id == 'bang' || o.id == 'base' || o.id == 'comma';
    }
    break;
  case 1 :    // sequence of digits seen
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.classList.contains('closer') &&
	(!lastopen.length ||
	 o.id == 'cparen' && last && last < 3 ||
	 o.id == 'powdn' && last != 1 ||
	 o.id == 'comma' && last != 2 && last != 3) || o.id =='base';
    }
    break;
  case 2 :    // variable or parenthesized expression seen
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.id == 'base' ||
	o.classList.contains('closer') &&
	(!lastopen.length ||
	 o.id == 'cparen' && last && last < 3 ||
	 o.id == 'powdn' && last != 1 ||
	 o.id == 'comma' && last != 2 && last != 3);
    }
    break;
  case 3 :    // need argument
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.classList.contains('closer') || o.id == 'powup' ||
	o.id == 'bang' || o.id == 'base' || o.classList.contains('binary');
    }
    break;
  case 4 :    // a decimal point has been seen
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.id == 'decpt' || o.id == 'base' ||
	o.classList.contains('closer') &&
	(!lastopen.length ||
	 o.id == 'cparen' && last && last < 3 ||
	 o.id == 'powdn' && last != 1 ||
	 o.id == 'comma' && last != 2 && last != 3);
    }
    break;
  case 5 :    // a lone decimal point
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled = !o.classList.contains('digit');
    }
    break;
  case 6 :    // log: only _ and ( are legal
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled = o.id != 'oparen' && o.id != 'base';
    }
    break;
  case 7 :    // atan or other fcn: only ( is legal
  case 8 :
  case 9 :
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled = o.id != 'oparen';
    }
    break;
  default :
    throw new Error('unknown parstate '+state);
  }
}

function rational(a) {    // convert a to rational: [numerator,denominator]
  if (!Number.isFinite(a)) return [a==a && Math.sign(a) || 0,0];
  if (Number.isInteger(a)) return [a,1];
  var b = Math.abs(a);
  var x = b;
  var m0=0, m1=1, n0=1, n1=0;
  var t0,t1;
  var i, c, ix, fx;
  for (i = 64; i--;) {
    ix = Math.floor(x);
    fx = x%1;
    t0 = n0;
    t1 = n1;
    n0 = m0 + ix*n0;
    n1 = m1 + ix*n1;
    m0 = t0;
    m1 = t1;
    if (fx == 0 || n0/n1 == b) break;
    x = 1/fx;
    if (!Number.isFinite(x)) break;
  }
  return [Math.sign(a)*n0,n1];
}

function xgcd(a,b) {    // extended gcd: return [g,u,v] where g=ua+vb
  var c=1, d=0, e=0, f=1;
  var g,h;
  var q,r;
  while (b) {
    q = Math.floor(a/b);
    r = a - q*b;
    g = e;
    h = f;
    e = c-q*e;
    f = d-q*f;
    c = g;
    d = h;
    a = b;
    b = r;
  }
  return a ? a < 0 ? [-a,-c,-d] : [a,c,d] : [0,0,0];
}

function factor(n,b) {    // factor n into primes up to (but not including) b
  if (!Number.isInteger || n < 1) {
    throw new TypeError('Only positive integers can be factored');
  }
  var f = {};
  if (n == 1) return f;
  if (b <= 2) return {n:1};
  var p = 2;
  while (!(n&1)) {
    f[p] = (f[p] || 0) + 1;
    n >>= 1;
  }
  if (n == 1) return f;
  for (p = 1; (p+=2) < b; ) {
    while (!(n%p)) {
      f[p] = (f[p] || 0) + 1;
      n /= p;
    }
    if (n == 1) return f;
  }
  f[n] = 1;
  return f;
}

function factorial(n) {
  if (n%1) {
    return Gamma(n+1);
  }
  if (n < 0) {
    return NaN;
  }
  if (n > 170) return Infinity;
  var x = 1;
  while (n) x*= n--;
  return x;
}		      

function sinc(x) {
  if (!x) return 1;
  return Math.sin(pi*(x%2))/(pi*x);
}

var gammacoeffs = [];
var gamma_a;    // use 20 for 54 bits of precision? 17 works better!
const gamma = .57721566490153286
const gamma0n = (pi**2-6*gamma**2)/12/gamma;
const gamma0d = (pi**2+6*gamma**2)/12/gamma;

function initGamma(a) {
  // For Spouge approximation
  gamma_a = a;
  gammacoeffs.length = 0;
  var k;
  gammacoeffs.push(tau**.5);
  for (k=1; k < a; k++) {
    gammacoeffs.push((-1)**k*(a-k)**(k-.5)*-Math.exp(a-k)/factorial(k-1));
  }
}

function Gamma0(x) {    // calculate Gamma for arg near (but not at) 0
  return Math.abs(x) < .00007912 ?
    (1+gamma0n*x)/(1+gamma0d*x)/x :    // near zero approximation is better 
    1/Gamma(2-x)/sinc(1-x);
}

function Gamma(x) {
  var g;
  var y = x%1;
  if (x < 1) {
    if (!y) return NaN;
    // Gamma(x) = Gamma(x+1)/x
    if (x > .5) {
      x--;    // Gamma(x) = Gamma(x-1)*(x-1)
      return Gamma0(x)*x;
    } else if (x > -.5) {
      return Gamma0(x);
    } else if (y < -.5) {
      g = Gamma0(++y);
    } else {
      g = Gamma0(y);
    }
    while (g && y > x) {
      g /= x++;
    }
    return g;
  }
  if (x > 172) {
    return Infinity;
  }
  // Spouge approximation
  var g = gammacoeffs[0];
  for (k=1; k < gamma_a; k++) {
    g += gammacoeffs[k]/(y+k);
  }
  g *= (y+gamma_a)**(y+.5)*Math.exp(-y-gamma_a);
  while (--x > 1) {    // Gamma(x) = (x-1)Gamma(x-1)
    g *= x;
  }
  return g;
}

function atan(y,x) {
  return Math.atan2(y,x==undefined?1:x);
}

function blog(b,a) {    // log, but with args reversed
  return Math.log(a)/Math.log(b);
}

function mod(a,b) {    // mathematical mod function
  // Note: javascript % is in (-|b|,|b|)
  if (!b) return NaN;
  b = Math.abs(b);
  var f,r,s;
  var p;    // prime factors
  if (Number.isInteger(b)) {   // integer modulus: value in [0,|b|).
    if (!Number.isInteger(a) && b != 1) {
      r = rational(a);
      f = factor(r[1],b);
      var x=r[0];
      for (p in f) {
	if (p >= b) {
	  x = 0;
	  break;
	}
	s = xgcd(p,b);
	if (s[0] != 1) {
	  x = 0;
	  break;
	}
	x *= s[1]**f[p];
      }
      if (x) return mod(x,b);
    }
    r = a%b;
    return r < 0 ? r + b : Math.abs(r);    // don't want -0
  } else {                     // noninteger modulus: value in (-b/2,b/2]
    r = a%b;
    return r > b/2 ? r-b : r <= -b/2 ? r+b : r;
  }
}

function expr2js(expr) { // convert math expression to javascript expression
  /* Until converted into a string, signs, digits, and variables are accumulated
     Unary signs are combined (0 for +, 1 for -). Unary + is never output.
     Binary sign is indicated as 1 for -, 2 for +.
     Digits are accumulated as a string.
     Variables are accumulated as a list of 1-character strings, but the
     variable list also includes subexpression strings, e.g. '14**(32)'
     ( ... ) gets converted and appended to vars [with the parens included]
     ?^{ ... } gets converted and ? is replaced by ?^( ) and appended to vars
     Subexpression conversions are trigger by ')', '}', or any operator.
     unary -?^? requires parens: -(?^?)
     unary -?%? requires parens: mod(-?,?)
  */
  const p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;    // for eval test at end
  const theta=0;
  var js = '';   // output javascript expression
  var sign;      // unary sign: 0 -> +, 1 -> -
  var digits;    // string of digits
  var vars;      // sequence of variables and subexpressions with implied multiplication
  var binary;    // 0 if first sign not binary, 1 if -, 2 if +
  var i,b,c,d;
  var recur = [];       // saved variables for recursion
  function reset() {    // start of subexpression
    sign = 0;
    digits = '';
    vars = [];
    binary = 0;
  }
  function finish(op) {    // lhs completed with binary op
    if (digits.length) {
      vars.push(digits);
    }
    if (!vars.length) {
      if (op.length) {
	throw new SyntaxError('No left hand arg for '+op+' at '+i);
      }
    } else {
      if (vars[0].slice(-1)==',') {    // complete mod
	vars[0] += vars.slice(1).join('*')+')';
	vars.length = 1;
	sign = 0;
	digits = '';
	binary = 0;
      }
      if (op=='%') {            // start mod
	vars[0] = 'mod(' + (sign ? '-1*' : '') + vars.join('*') + ',';
	vars.length = 1;
	sign = 0;
	digits = '';
      } else {    // append js with unary sign and accumulated vars, followed by op
	js += (binary ? '+-'[(binary+sign)&1] : sign ? '-' : '') + 
	  ((vars.length > 1 || !binary && sign && vars[0].indexOf('**') >= 0) ? 
	   '(' + vars.join('*') + ')' : vars[0]) + op;
	reset();
      }
    }
  }
  function usign(op) {    // accumulate unary signs
    var j;         // 0 -> +, 1-> -
    var unary=0;   // for accumulating signs
    while (i < expr.length-1) {
      if ((j = '+-'.indexOf(expr[i+1])) < 0) break;
      unary ^= j;
      ++i;
    }
    if (digits.length || vars.length) {    // binary op
      finish(op);
      sign = unary;
    } else {
      sign ^= '+-'.indexOf(op) ^ unary;
    }
  }
  reset();
  for (i=0; i < expr.length; i++) {
    c = expr[i];
    switch (c) {
    case '\\':
      c = expr.slice(i+1).match(/(^\w*)\s*/);
      i += 1+c[0].length;
      switch (c[1]) {
      case 'bmod' :
	i--;
	finish('%');
	break;
      case 'log_' :
	if (digits.length) {
	  vars.push(digits);
	}
	if ((c=expr[i]) != '{') {
	  throw new SyntaxError('Improper base at '+i);
	}
	// process base (ending in })
	vars.push('blog(');
	recur.push(
	  {c:c,js:js,sign:sign,vars:vars,binary:binary});
	js = '';
	reset();
	break;
      case 'log' :
	if (digits.length) {
	  vars.push(digits);
	}
	if ((c=expr[i]) != '(') {
	  throw new SyntaxError('log arg must be parenthesized');
	}
	vars.push('blog(e,');
	recur.push(	  // process arg ending in )
	  {c:c,js:js,sign:sign,vars:vars,binary:binary});
	js = '';
	reset();
	break;
      case 'atan' :
	if ((c=expr[i]) != '(') {
	  throw new SyntaxError('Improper arg at '+i);
	}
	if (digits.length) {
	  vars.push(digits);
	}
	// first arg ends with , or only arg ends with )
	vars.push('atan(');
	recur.push(
	    {c:c,js:js,sign:sign,vars:vars,binary:binary});
	js = '';
	reset();
	break;
      default :
	if (digits.length) {
	  vars.push(digits);
	}
	vars.push('Math.'+c[1]+'(');
	if ((c=expr[i]) != '(' && c != '{') {
	  throw new SyntaxError('Improper arg at '+i);
	}
	recur.push(
	  {c:c,js:js,sign:sign,vars:vars,binary:binary});
	js = '';
	reset()
	break;
      }
      break;
    case ',' :    // first arg of atan
      if (!recur.length) {
	throw new SyntaxError('Unexpected comma at position '+i);
      }
      finish(',');
      b = recur[recur.length-1];
      b.vars[b.vars.length-1] += js;
      js = '';
      reset();
      break;
    case '^' :
      if ((c=expr[++i]) != '{') {
	throw new SyntaxError('Improper exponent at '+i);
      }
      if (digits.length) {
	vars.push(digits);
      }
      if (vars.length) {
	vars.push(vars.pop() + '**(');
      } else {
	throw new SyntaxError('Exponent without base at position '+i);
      }
      recur.push(
	{c:c,js:js,sign:sign,vars:vars,binary:binary});
      js = '';
      reset();
      break;
    case '{' :
    case '(' :
      if (digits.length) {
	vars.push(digits);
      }
     recur.push(
	{c:c,js:js,sign:sign,vars:vars,binary:binary});
      js = c;
      reset();
      break;
    case '}' :    // terminates ^ or _ or \abs
    case ')' :    // terminates (
      if (!recur.length) {
	throw new SyntaxError('Unmatched '+c+' at position '+i);
      }
      b = recur[recur.length-1];
      if (b.vars.length && b.vars[b.vars.length-1] == 'blog(') {
	if ((c=expr[++i]) != '(') {
	  throw new SyntaxError('log arg must be parenthesized');
	}
	b.c = c;
	finish(',');
	b.vars[b.vars.length-1] += js;
	js = '';
	reset();
	break;
      }
      finish(')');
      b = recur.pop();
      vars = b.vars;
      binary = b.binary;
      if (b.vars.length &&
	  ((d = b.vars[b.vars.length-1].slice(-1)) == ',' || d == '(')) {
	b.vars[b.vars.length-1] += js;
      } else {
	vars.push(js);
      }
      digits = '';
      sign = b.sign;
      js = b.js;
      b = b.c;
      if (!(b == '(' && c == ')' || b == '{' && c == '}')) {
	throw new SyntaxError('Unmatched '+c+' at position '+i);
      }
      break;
    case '+' :
    case '-' :
      usign(c);
      break;
    case '\u00d7' :    //times
      finish('*');
      break;
    case '\u00f7' :    //divide
      finish('/');
      break;
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      digits += c;
      break;
    case '.':
      if (digits.indexOf('.') >= 0) {
	throw new SyntaxError('Multiple decimal points');
      }
      digits += c;
      break;
    case '!':
      if (digits.length) {
	vars.push(digits);
	digits = '';
      }
      vars.push('factorial('+vars.pop()+')');
      digits = '';
      break;
    case '\u03b8':
      c = 'theta';
    case '\u03c0':
      if (c.length == 1) c = 'pi';
    case '\u03c4':
      if (c.length == 1) c = 'tau';
    case 'e':
    case 'p': case 'q': case 'r': case 's': case 't':
    case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':
      if (digits.length) {
	vars.push(digits);
	digits = '';
      }
      vars.push(c);
      break;
    default :
      throw new SyntaxError('Unrecognized symbol');
    }
  }
  if (recur.length) {
    throw new SyntaxError('Premature termination of expression');
  }
  finish('');
  eval(js);    // might get syntax error
  return js;
}

function variables(expr) {    // return frequency of variables in expression
  var d = {};
  var i,c;
  const m = expr.match(/\w+/g);
  for (i in m) {
    c = m[i];
    if (c.length == 1 && 'p'<=c && c<='z' || c=='theta') {
      if (c in d) {
	d[c] += 1;
      } else {
	d[c] = 1;
      }
    }
  }
  return d;     
}

function length(o) {    // return length of object
  return Object.keys(o).length;
}

function fulleval(vin,obj) {    // evaluate variable v using dictionary o
  if (tvars[vin][vin] != undefined) {
    throw new Error('self-referential variable '+vin);
  }
  var win;
  for (win in vvars[vin]) {
    if (obj[win] == undefined) fulleval(win,obj);
  }
  for (win in obj) {
    eval('var '+win+'=obj[win];');
  }
  return (obj[vin]=eval(vv[vin]));
}

function updateLimits(event) {
  addplot(plottedvars);  
}

function plot() {    // plot expressions
  // automatically compute limits ?
  const b = document.getElementById('exprboxes').getElementsByClassName('down');
  var i;
  var vars = [];
  for (i=0; i<b.length; i++) {
    vars.push(b[i].previousElementSibling.id.slice(-1));
  }
  addplot(vars);
}

const side = 513;

function addplot(vars) {    // plot expressions with current limits
  plottedvars = vars.slice();
  const x0 = document.getElementById('lft').valueAsNumber;
  const x1 = document.getElementById('rgt').valueAsNumber;  
  const y0 = document.getElementById('bot').valueAsNumber;
  const y1 = document.getElementById('top').valueAsNumber;  
  var n,i,j,k;
  var hi,hj,oi,oj;    // old values to decide between moveTo and lineTo
  var d;    // distance between old and new points
  var v;
  var x;
  var y;
  var r,theta;
  var l;
  var changed = true;
  ctx.clearRect(0,0,side,side);
  if (!(x0<x1 && y0<y1)) {
    ctx.font = '50px Arial';
    ctx.textAlign = 'center';
    ctx.fillText("Range Error",side/2,side/2);
    throw new Error('Low Limits Must Be Less Than High Limits');
  }
  vvars = {};
  for (v in vv) {
    vvars[v] = variables(vv[v]);
    tvars[v] = Object.assign({},vvars[v]);
  }
  while (changed) {
    changed = false;
    for (v in vvars) {
      l = length(tvars[v]);
      for (w in tvars[v]) {
	Object.assign(tvars[v],tvars[w]);
      }
      changed |= l != length(tvars[v]);
    }
  }
  ctx.strokeStyle='gray';
  if (x0 < 0 && 0 < x1) {
    ctx.beginPath();
    ctx.moveTo((1-side)*x0/(x1-x0),0);
    ctx.lineTo((1-side)*x0/(x1-x0),side);
    ctx.stroke();
  }
  if (y0 < 0 && 0 < y1) {
    ctx.beginPath();
    ctx.moveTo(0,(side-1)*y1/(y1-y0));
    ctx.lineTo(side,(side-1)*y1/(y1-y0));
    ctx.stroke();
  }
  ctx.strokeStyle='black';
  for (n in vars) {
    ctx.beginPath();
    if (tvars[vars[n]]['x']) {
      for (i = 0; i <= side-1; i += .5) {
	x = x0 + i*(x1-x0)/(side-1);
	y = fulleval(vars[n],{x:x});
	j = (side-1)*(y1-y)/(y1-y0);
	if (!Number.isInteger(i)) {
	  hj = j;
	} else {
	  if (!i) {
	    ctx.moveTo(i,j);
	  } else {
	    d = .875*Math.abs(j-oj);
	    d < 2 || Math.abs(hj-oj) < d && Math.abs(j-hj) < d ?
	      ctx.lineTo(i,j) : ctx.moveTo(i,j);
	  }
	  oj = j;
	}
      }
    } else if (tvars[vars[n]]['y']) {
      for (j = 0; j <= side-1; j += .5) {
	y = y1 - j*(y1-y0)/(side-1);
	x = fulleval(vars[n],{y:y});
	i = (side-1)*(x-x0)/(x1-x0);
	if (!Number.isInteger(j)) {
	  hi = i;
	} else {
	  if (!j) {
	    ctx.moveTo(i,j);
	  } else {
	    d = .875*Math.abs(i-oi);
	    d < 2 || Math.abs(hi-oi) < d && Math.abs(i-hi) < d ?
	      ctx.lineTo(i,j) : ctx.moveTo(i,j);
	  }
	  oi = i;
	}
      }
    } else if (tvars[vars[n]]['theta']) {
      for (k = 0; k <= 360; k += .5) {
	theta = pi*k/180;
	r = fulleval(vars[n],{theta:theta});
	x = r*Math.cos(theta);
	y = r*Math.sin(theta);
	i = (side-1)*(x-x0)/(x1-x0);
	j = (side-1)*(y1-y)/(y1-y0);
	if (!Number.isInteger(k)) {
	  hi = i;
	  hj = j;
	} else {
	  if (!k) {
	    ctx.moveTo(i,j);
	  } else {
	    d = .75*((i-oi)**2 + (j-oj)**2);
	    d < 4 || (hi-oi)**2+(hj-oj)**2 < d && (i-hi)**2+(j-hj)**2 < d ?
	      ctx.lineTo(i,j) : ctx.moveTo(i,j);
	  }
	  oi = i;
	  oj = j;
	}
      }
    }
    ctx.stroke();
  }
}

function showhidenext(o) {
  if (o.innerHTML=='Hide') {
    o.nextElementSibling.style.display='none';
    o.innerHTML = 'Show';
  } else {
    o.nextElementSibling.style.display='inline';
    o.innerHTML = 'Hide';
  }
}

function showhelp(s) {
  var o = document.getElementById(s);
  o.style.display='block';
}		      

function showpopup(o,s) {
  var b = document.body.getClientRects()[0];
  var r = o.getClientRects()[0];
  o = document.getElementById(s);
  o.style.display='block';
  var q = o.getClientRects()[0];
  o.style.position = 'absolute';
  o.style.left = Math.max(window.scrollX,
			  Math.min(window.scrollX+window.innerWidth-q.width,
				   (r.width-q.width)/2))+'px';
  o.style.top = Math.max(window.scrollY,
			 Math.min(window.scrollY+window.innerHeight-q.height,
				  (r.top+r.bottom-q.height)/2-b.top))+'px';
}

function advance(event) {
  event.stopPropagation();
  document.querySelectorAll('.ex').forEach(
    function(e){e.style.display='inline-block';});
  event.target.parentElement.style.display='none';
}

/* thoughts:
   Is there a way to do log?
   Graph of variable dependencies (must be tree ...
   ...  unless we want to solve simultaneous equations)
*/
/* idea for new scheme:
   boxes for constants, variables, numbers, operations; arrows for interaction
   ... converted to math expressions
   always one output, but possible multiple inputs, e.g. atan, b^x, log_b x
   ... the last two defaulting b to e
   ... log without paren terminates with any operator except unary +- or ^
   ... should we allow log^ ? probably not
   ... Sum and Product ?
*/
</script>
<style>
.invisible {display:none}
#debugger {
  font-size:1em;
}
#debug {
  display:none;
}
button {
  margin:2px;
  font-size:18px;
}    
#mathbox {
  margin-bottom:2px;
}
#bs {margin-left:32px;}
#expression {display:inline;}
#exprdiv {
  overflow:hidden;
  white-space:nowrap;
  width:512px;
}
.var {
  font-family:serif;
  font-style:italic;
}
.varlabel {
  font-family:serif;
  font-style:italic;
  text-align:center;
  margin:0;
}
.ex {
  display:none;
}    
.popup {
  background-color:white;
  display:none;
  z-index:1;
  position:absolute;
  top:0;
  left:0;
  padding:6px;
  margin:6px;
  border:1px solid black;
  max-width:inherit;
}
#topbox {
  display:grid;
  grid-template-columns: 460px 60px;
  align-items:center;
}
#exprboxes {
  display:grid;
  grid-template-columns: 20px 440px 60px;
  row-gap:2px;
  align-items:center;
  margin-top:2px;
}
#exprboxes button {
  margin-left:4px;
  width:50px;
  font-size:12px;
}
.exprbox {
  display:flex;
  justify-content:center;
  align-items:center;
  width:440px;
  height:32px;
  border:1px solid black;
  padding:0;
  margin:0;
  text-align:center;
  overflow-x:auto;
  overflow-y:hidden;
}
.exprbox * {
  cursor:grab;
}
.up {
  background-color:white;  
}
.down {
  background-color:pink;
}
#mathdiv {
  margin-top:10px;
  float:left;
}
#keyboard {
  display:inline;
  margin-left:20px;
  text-decoration:underline;
  cursor:context-menu;
}
#plot {
  float:left;
  display:grid;
  grid-template-columns: 20px 100px 313px 100px;
  grid-template-rows: 100px 313px 100px 20px;
  margin-top:10px;
  margin-left:10px;
}
input[type=number]::-webkit-outer-spin-button,
input[type=number]::-webkit-inner-spin-button {
  -webkit-appearance:none;
  margin:0;
}
input[type=number] {
  width:100px;
  height:20px;
  margin:0;
  box-sizing:border-box;
  -moz-appearance:textfield;
  appearance:textfield;
}
#top {
  grid-column-start:1;
  grid-row-start:1;
  transform:rotate(-90deg);
  transform-origin:50px 50px;
  text-align:right;
}
#bot {
  grid-column-start:1;
  grid-row-start:3;
  transform:rotate(-90deg);
  transform-origin:50px 50px;
  text-align:left;
}
#lft {
  grid-column-start:2;
  grid-row-start:4;
  text-align:left;
}
#rgt {
  grid-column-start:4;
  grid-row-start:4;
  text-align:right;
}
#canvas {
  grid-column-start:2;
  grid-column-end:span 3;
  grid-row-start:1;
  grid-row-end:span 3;
  width:513px;
  height:513px;
}
#x {
  grid-row-start:4;
  grid-column-start:3;
}
#y {
  grid-row-start:2;
  grid-column-start:1;
  align-self:center;
}
p.top {
  background-color:white;
  z-index:1;
  position:fixed;
  left:0;top:0;
  text-align:left;
  font-size:.75em;
  margin:0;
}
#helper {
  text-decoration:underline;
  font-size:11px;
  cursor:context-menu;
  margin-left:60px;
}
#help {
  position:absolute;
  left:270px;top:0;
  width:750px;
}
h2 {
  text-align:center;
  margin-top:0;
}
ul {
  padding-left:1em;
  padding-top:0;
}
li {
  text-indent:.25em;
}
table {
  border-collapse:collapse;
  margin:0 auto;
}
td {
  text-align:center;
  width:30px;
}
span {
  text-decoration:underline;
  cursor:context-menu;
}
.nopoint {
  pointer-events:none;
}
.copy {
  cursor:copy;
}
</style>
</head>
<body onload='init()'>
<p class='top'>
<p class='invisible'>\(\DeclareMathOperator{\sgn}{sgn}\)</p>
<p class='invisible'>\(\DeclareMathOperator{\asin}{asin}\)</p>
<p class='invisible'>\(\DeclareMathOperator{\acos}{acos}\)</p>
<p class='invisible'>\(\DeclareMathOperator{\atan}{atan}\)</p>
<p class='invisible'>\(\DeclareMathOperator{\asinh}{asinh}\)</p>
<p class='invisible'>\(\DeclareMathOperator{\acosh}{acosh}\)</p>
<p class='invisible'>\(\DeclareMathOperator{\atanh}{atanh}\)</p>
<p class='invisible'>\(\DeclarePairedDelimiters{\abs}{\lvert}{\rvert}\)</p>
  <a href='fib.html'>Fi &amp; Lu</a>&nbsp;
  <a href='area.html'>Area</a>&nbsp;
  <a href='algebra.html'>Algebra</a>
  <a href='trig.html'>Trigonometry</a>&nbsp;
  <a href='func.html'>Functions</a>&nbsp;
  <a href='complex.html'>Complex Numbers</a>&nbsp;
  <a href='calc.html'>Calculus</a>
  <span id='helper' onclick="showhelp('help')">HELP</span>
</p>
<div id='mathdiv'>
<div id='topbox'>
<div id='mathbox' class='exprbox' title='math expression; drag to a labeled box below to plot'><p id='math' draggable='true'></p></div>
<button id='clear'>Clear</button>
</div>
<div id='exprdiv'><p id='expression' contenteditable='plaintext-only'></p><br></div>
<div id='exprbuttons' tabindex='0'>
<button class='var' title='theta (h)' key='h'>&theta;</button>
<button class='var'>p</button>
<button class='var'>q</button>
<button class='var'>r</button>
<button class='var'>s</button>
<button class='var'>t</button>
<button class='var'>u</button>
<button class='var'>v</button>
<button class='var'>w</button>
<button class='var'>x</button>
<button class='var'>y</button>
<button class='var'>z</button>
<button id='bs'>Backspace</button>
<br>
<button class='var'>e</button>
<button class='var' title='pi (i)' key='i'>&pi;</button>
<button class='var' title='tau=2pi (j)' key='j'>&tau;</button>
<button class='digit'>0</button>
<button class='digit'>1</button>
<button class='digit'>2</button>
<button class='digit'>3</button>
<button class='digit'>4</button>
<button class='digit'>5</button>
<button class='digit'>6</button>
<button class='digit'>7</button>
<button class='digit'>8</button>
<button class='digit'>9</button>
<button id='decpt'>.</button>
<button id='bang' title='factorial'>!</button>
<br>
<button id='plus' class='op' title='plus (+)' key='+'>+</button>
<button id='minus' class='op' title='minus (-)' key='-'>&minus;</button>
<button id='times' class='op binary' title='times (*)' key='*'>&times;</button>
<button id='divide' class='op binary' title='divide (/)' key='/'>&divide;</button>
<button id='mod' class='op binary' title='modulo (%)' key='%'>mod</button>
<button id='powup' class='op' title='exponentiate (^)' key='^'>&uparrow;</button>
<button id='powdn' class='op closer' title='end exponent (\)' key='\\'>&downarrow;</button>
<button id='sgn' class='op' title='signum (S)' key='S'>sgn</button>
<button id='abs' class='op' title='absolute value (V)' key='V'>abs</button>
<button id='oparen' class='op' key='('>(</button>
<button id='cparen' class='op closer' key=')'>)</button>
<br>
<button id='exp' class='op ex' title='exp (E)' key='E'>exp</button>
<button id='log' class='op ex' title='logarithm (l), default base = e' key='l'>log</button>
<button id='base' class='op ex' title='base of log, terminated with comma' key='_'>_</button>
<button id='comma' class='op closer ex' title='end base or first arg' key=','>,</button>
<button id='sin' class='op ex' title='sine (b)' key='b'>sin</button>
<button id='cos' class='op ex' title='cosine (c)' key='c'>cos</button>
<button id='tan' class='op ex' title='tangent (d)' key='d'>tan</button>
<button id='asin' class='op ex' title='arcsine (f)' key='f'>asin</button>
<button id='acos' class='op ex' title='arccosine (g)' key='g'>acos</button>
<button id='atan' class='op ex' title='arctangent (a), 1 or 2 args' key='a'>atan</button>
<br>
<button id='sinh' class='op ex' title='hyperbolic sine (B)' key='B'>sinh</button>
<button id='cosh' class='op ex' title='hyperbolic cosine (C)' key='C'>cosh</button>
<button id='tanh' class='op ex' title='hyperbolic tangent (D)' key='D'>tanh</button>
<button id='asinh' class='op ex' title='arg hyperbolic sine (F)' key='F'>asinh</button>
<button id='acosh' class='op ex' title='arg hyperbolic cosine (G)' key='G'>acosh</button>
<button id='atanh' class='op ex' title='arg hyperbolic tangent (A)' key='A'>atanh</button>
</div>
<div id='exprboxes'>
<p class='varlabel'>p</p><div id='mathboxp' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>q</p><div id='mathboxq' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>r</p><div id='mathboxr' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>s</p><div id='mathboxs' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>t</p><div id='mathboxt' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>u</p><div id='mathboxu' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>v</p><div id='mathboxv' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>w</p><div id='mathboxw' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>x</p><div id='mathboxx' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>y</p><div id='mathboxy' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>z</p><div id='mathboxz' class='exprbox'></div><button class='up'>PLOT</button>
</div>
<button id='debugger' onclick='showhidenext(this)' title='show/hide javascript code for current math expression'>Show</button>
<p id='debug'></p>  
</div>
<!--Plotting
    We have a canvas for the plot
    To the left we have two input elements for upper and lower ordinate limits
    On the top we have two input elements for lower and upper abscissa limits
    The limits can be auto-set based on what is being plotted?
-->
<div id='plot'>
  <input id='top' class='lim' type='number'></input>
  <p id='y' class='varlabel'>y</p>
  <input id='bot' class='lim' type='number'></input>
  <canvas id='canvas'></canvas>
  <input id='lft' class='lim' type='number'></input>
  <p id='x' class='varlabel'>x</p>
  <input id='rgt' class='lim' type='number'></input>
  </div>
</div>
<div id='help' class='popup' onclick='this.style.display="none";'>
<h2>Entering and plotting mathematical expressions</h2>
<p>Use the buttons and/or your keyboard to enter mathematical expressions. Special keyboard equivalents:</p>
<table><tbody><tr><td>%</td><td>S</td><td>V</td><td>h</td><td>i</td><td>j</td><td>-</td><td>*</td><td>/</td><td>^</td><td>\</td></tr>
<td>mod</td><td>sgn</td><td>|abs|</td><td>&#x03b8;</td><td>&#x03c0;</td><td>&#x03c4;</td><td>&#x2212;</td><td>&#x00d7;</td><td>&#x00f7;</td><td>&#x2191;</td><td>&#x2193;</td></tr></tbody></table>
<p>Buttons that are grayed out, and their keyboard equivalents, are not valid and are ignored. Mathematical expressions can be dragged between boxes. Variables are defined by the mathematical expressions in their correspondingly labeled boxes. If any variable is defined using itself, it cannot be used for plotting.</p>
<p>Depressing a PLOT button plots the mathematical expression to its left:</p>
<ul>
<li>If the expression ultimately evaluates with a free variable \(x\), \(y=f(x)\) is plotted.</li>
<li>If the expression ultimately evaluates with a free variable \(y\), \(x=f(y)\) is plotted.</li>
<li>If the expression ultimately evaluates with a free variable \(\theta\), \(r=f(\theta)\) is plotted.</li>
<li>To plot a constant function, use an expression with the free variable multiplied by 0.</li>
</ul>
<p>The \(x\) and \(y\) limits of the plot are determined by the bottom and left input boxes, respectively.</p>
<p>Here&rsquo;s an example to try:</p>
<ul>
  <li>Enter <span class='copy' onclick='copyandpaste(event)'><span class='nopoint'>\(1-p^{2}&divide;2+p^{4}&divide;4!-p^{6}&divide;6!+p^{8}&divide;8!-p^{10}&divide;10!\)</span></span> and drag it to box \(q\). (Remember, use the &uparrow; button or the ^ key to exponentiate, and the &downarrow; button or \ key to end the exponent.)</li>
<li>Then enter <span class='copy' onclick='copyandpaste(event)'><span class='nopoint'>\(t\bmod\tau\)</span></span> and drag it to box \(p\). (Remember, use the mod button or % key for mod, the \(\tau\) button or j key for \(\tau\).)</li>
<li>Finally, enter <span class='copy' onclick='copyandpaste(event)'><span class='nopoint'>\(\tau x\)</span></span> and drag it to box \(t\) and click PLOT at box \(q\).</li>
  <li>After observing the result, enter <span class='copy' onclick='copyandpaste(event)'><span class='nopoint'>\(5\theta\)</span></span> and drag it to box \(t\).</li>
</ul>
<p>This should give you a flavor of what can be done. <b>Click to hide this popup.</b></p>
<p><span onclick='advance(event)'>Enable advanced math functions</span>:</p>
<table><tbody><tr><td>E</td><td>l</td><td>b</td><td>c</td><td>d</td><td>f</td><td>g</td><td>a</td><td>B</td><td>C</td><td>D</td><td>F</td><td>G</td><td>A</td></tr>
<tr><td>exp</td><td>log</td><td>sin</td><td>cos</td><td>tan</td><td>asin</td><td>acos</td><td>atan</td><td>sinh</td><td>cosh</td><td>tanh</td><td>asinh</td><td>acosh</td><td>atanh</td></tr></tbody></table>
</div>
</body>
</html>
<!--We enter mathematical expressions by clicking on components
    Simultaneously we parse the expression and keep the result separately
    We may need to reparse when we delete (using backspace or delete key)
    We can keep multiple expressions in an array, displaying all of them
    To plot expressions we may color code so more than one can appear together
    Plot may compute range and domain, or user may adjust with cursor or other command
    Current expression is selected by cursor for input or editing
    ) closes (, provided it's on the same exponent level
    v closes ^, provided there are no unclosed (s
    Only legitimate continuations of expression can be selected (others are grayed out)
    Selections:
    operators: + - x / mod ^ v ( ) (square?root??)
    variables: r s t u v w x y z (concatenation is multiplication)
    constants: 0 1 2 3 4 5 6 7 8 9 (concatenation is concatenation) !

    additional operators: log_b x, atan(y,x)
      atan first arg can be terminated with , or ). If ), second arg is 1.
    allow restricted mode where some operations/variables don't appear?

    commands: new? plot?     
    = ?
    apply op arg to both sides ?
    apply "first" operation (possibly of given kind?)
    keep stack of operations so can undo
    can we color operations that are doable?
    for polynomials (in one or more variables), gather?
    apply commute, distribute ?
-->
