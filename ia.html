<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js">
</script>
<script>
const pi = Math.PI;
const tau = 2*pi;
const e = Math.E;

var expression;    // input string for math expression
var parsetable;    // dictionary keyname->buttonelement
var exprbuttons;   // keys to enter components of math expression
var vv = {};       // variable -> expression
var plottedvars = [];    // last array of variables that were plotted
var vvars = {};    // variable -> list of variables found in vv[variable]
var tvars = {};    // transitive closure of vvars

var cvs;
var ctx;

function init() {
  const W = window.innerWidth;
  expression = document.getElementById('expression');
  expression.innerHTML = '';
  parsetable = {};
  exprbuttons = [];
  document.body.addEventListener('keydown',algkey);
  var i;
  var b;
  b = document.getElementById('exprbuttons').children;
  for (i=0; i < b.length; i++) {
    if (b[i].id == 'keyboard') {
    } else if (b[i].id == 'bs') {
      b[i].addEventListener('click',bs);
    } else {
      b[i].addEventListener('click',bp);
      parsetable[b[i].innerHTML] = b[i];
      exprbuttons.push(b[i]);
    }
  }
  b = document.getElementsByClassName('exprbox');
  for (i=0; i < b.length; i++) {
    b[i].addEventListener('dragstart',dragStartHandler);
    b[i].addEventListener('drop',dropHandler);
    b[i].addEventListener('dragover',dragoverHandler);
  }  
  b = document.getElementById('exprboxes').getElementsByTagName('button');
  for (i=0; i < b.length; i++) {
    b[i].addEventListener('click',toggle);
  }
  cvs = document.getElementById('canvas');
  cvs.width = side;
  cvs.height = side;
  ctx = cvs.getContext('2d');
  ctx.lineWidth = 1;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.strokeStyle = 'black';
  parse();
  document.getElementById('bot').value = -1;
  document.getElementById('top').value = 1;
  document.getElementById('lft').value = -1;
  document.getElementById('rgt').value = 1;  
  b = document.getElementsByTagName('input');
  for (i=0; i < b.length; i++) {
    b[i].step=.125;
    b[i].addEventListener('change',updateLimits);
  }
  MathJax.startup.output.options.linebreaks.inline = false;
}

function dragStartHandler(event) {
  event.dataTransfer.setData('text',event.target.id);
}

function dragoverHandler(event) {
  event.preventDefault();
}

function dropHandler(event) {
  event.preventDefault();
  const data = event.dataTransfer.getData('text');
  var t = event.target;
  while (t.id.slice(0,7) != 'mathbox') t = t.parentNode;
  const n = t.id.slice(7);
  const m = MathJax.startup.document.getMathItemsWithin([document.getElementById(data)])[0].math;
  const x = "<p id='math" + n + "' draggable='true'>\\(" + m + "\\)</p>";
  MathJax.typesetClear([t]);
  t.innerHTML = x;
  MathJax.typeset([t]);
  if (n) {
    vv[n] = expr2js(m);
    plot();
  } else {
    document.getElementById('expression').innerHTML = m
      .replace(/-/g,document.getElementById('minus').innerHTML)
      .replace(/\^{/g,document.getElementById('powup').innerHTML)
      .replace(/}/g,document.getElementById('powdn').innerHTML);
    document.getElementById('debug').innerHTML = expr2js(m);
    if (t.scrollWidth > t.clientWidth) t.scrollLeft = t.scrollWidth-t.clientWidth;
  }
}

function toggle(event) {
  event.preventDefault();
  var t = event.target;
  if (t.classList.contains('up')) {
    t.classList.remove('up');
    t.classList.add('down');
  } else if (t.classList.contains('down')) {
    t.classList.remove('down');
    t.classList.add('up');
  }    
  plot();
}

function algkey(event) {    // key down
  if (event.target.tagName == 'INPUT') return;
  event.preventDefault();
  const k = event.key;
  var o;
  if (k == 'Backspace') {
    expression.innerHTML = expression.innerHTML.slice(0,-1);
  } else if ('0' <= k && k <= '9') {
    expression.innerHTML += k;
  } else if ('p' <= k && k <= 'z' || k == 'e') {
    o = document.getElementsByClassName('var')[0];
    if (!o.disabled) expression.innerHTML += k;
  } else if (k == '+') {
    o = document.getElementById('plus');
    if (!o.disabled) expression.innerHTML += k;
  } else if (k == '-') {
    o = document.getElementById('minus');
    if (!o.disabled) expression.innerHTML += o.innerHTML;
  } else if (k == '.') {
    o = document.getElementById('decpt');
    if (!o.disabled) expression.innerHTML += k;
  } else if (k == '(') {
    o = document.getElementById('oparen');
    if (!o.disabled) expression.innerHTML += k;
  } else if (k == ')') {
    o = document.getElementById('cparen');
    if (!o.disabled) expression.innerHTML += k;
  } else if (k == '^') {
    o = document.getElementById('powup');
    if (!o.disabled) expression.innerHTML += o.innerHTML;
  } else if (k == '*') {
    o = document.getElementById('times');
    if (!o.disabled) expression.innerHTML += o.innerHTML;
  } else if (k == '/') {
    o = document.getElementById('divide');
    if (!o.disabled) expression.innerHTML += o.innerHTML;
  } else if (k == '%') {
    o = document.getElementById('mod');
    if (!o.disabled) expression.innerHTML += o.innerHTML;
  } else if (k == '\\') {
    o = document.getElementById('powdn');
    if (!o.disabled) expression.innerHTML += o.innerHTML;
  } else if (k == '!') {
    o = document.getElementById('bang');
    if (!o.disabled) expression.innerHTML += k;
  } else {
    return;
  }
  parse();
}

function bs(event) {    // backspace pressed
  expression.innerHTML = expression.innerHTML.slice(0,-1);
  parse();
}

function bp(event) {    // button pressed
  const o = event.target;
  var c = o.innerHTML;
  expression.innerHTML += c;
  parse();
}

var parstate;    /* 0: initial or after unary operator (can't have ^)
		    1: accumulating digits
		    2: accumulating variables
		    3: need binary argument
		    4: accumulating digits and . seen
		    5: . is only "digit"
		 */
var lastopen = [];    // stack; 0:(, 1:^

function parse() {    // parse expression and return as latex string
  /* depending on current value of expression, disable some buttons
     times, divide, and power can only follow a digit or variable
     digits cannot follow variables
     but + and - can be unary and so can follow any operations
     ) is only enabled when there is a matching ( on the same power level
     v is only enabled when the parens match within the power level
     Should we render divide as a fraction, and group multiplications
     in both the numerator and denominator, making / have lower precedence?
  */
  var i;
  var c,o;
  var s = expression.innerHTML;
  var m = '\\(';    // math string
  o = document.getElementById('exprdiv');
  if (o.scrollWidth > o.clientWidth) o.scrollLeft = o.scrollWidth-o.clientWidth;
  parstate = 0;
  lastopen.length = 0;
  for (i = 0; i < s.length; i++) {
    c = s[i];
    o = parsetable[c];
    switch (o.id) {
    case 'oparen' :
      parstate = 0;
      lastopen.push(0);
      m += c;
      break;
    case 'cparen' :
      if (lastopen[lastopen.length-1] == 0) lastopen.pop();
      parstate = 2;
      m += c;
      break;
    case 'powup' :
      parstate = 0;
      lastopen.push(1);
      m += '^{'
      break;
    case 'powdn' :
      lastopen.pop();
      parstate = 2;
      m += '}';
      break;
    case 'minus' :
      c = '-';
    default :
      if (c == '%') c = '\\bmod ';
      m += c;
      if (c == '.') {
	parstate = parstate == 1 ? 4 : 5;
      } else {
	parstate = !o.classList.contains('binary') ?
	  (!o.classList.contains('op') ?
	   (!o.classList.contains('digit') ? 2 : parstate < 4 ? 1 : 4) :
	   (parstate ? 3 : 0)) : 3;
      }
    }
  }
  setkeys(parstate);
  while ((i = lastopen.pop()) != undefined) m += i ? '}' : '';
  m += '\\)';
  document.getElementById('debug').innerHTML = expr2js(m.slice(2,-2));
  MathJax.typesetClear([document.getElementById('mathbox')]);
  document.getElementById('math').innerHTML = m;
  MathJax.typeset(['#math']);
  o = document.getElementById('mathbox');
  if (o.scrollWidth > o.clientWidth) o.scrollLeft = o.scrollWidth-o.clientWidth;
}

function setkeys(state) {
  /* enable and disable keys as appropriate for the state
  */
  var i;
  var o;
  switch (state) {
  case 0 :    // start of subexpression
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.classList.contains('binary') || o.id.indexOf('pow') >= 0 ||
	o.id == 'cparen' || o.id == 'bang';
    }
    break;
  case 1 :    // sequence of digits seen
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.classList.contains('closer') &&
	(o.id == 'cparen' && lastopen[lastopen.length-1] != 0 ||
	 o.id == 'powdn' && lastopen[lastopen.length-1] != 1);
    }
    break;
  case 2 :    // variable or parenthesized expression seen
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.id == 'bang' ||
	o.classList.contains('closer') &&
	(o.id == 'cparen' && lastopen[lastopen.length-1] != 0 ||
	 o.id == 'powdn' && lastopen[lastopen.length-1] != 1);
    }
    break;
  case 3 :    // need argument
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.classList.contains('closer') || o.id == 'powup' ||
	o.id == 'bang' || o.classList.contains('binary');
    }
    break;
  case 4 :    // a decimal point has been seen
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled =
	o.id == 'decpt' || o.id == 'bang' ||
	o.classList.contains('closer') &&
	(o.id == 'cparen' && lastopen[lastopen.length-1] != 0 ||
	 o.id == 'powdn' && lastopen[lastopen.length-1] != 1);
    }
    break;
  case 5 :    // a lone decimal point
    for (i=0; i < exprbuttons.length; i++) {
      o = exprbuttons[i];
      o.disabled = !o.classList.contains('digit');
    }
  }
}

function expr2js(expr) { // convert math expression to javascript expression
  /* Until converted into a string, signs, digits, and variables are accumulated
     Signs are counted (1 for -, 2 for +).
     Digits are accumulated as a string.
     Variables are accumulated as a list of 1-character strings, but the
     variable list also includes subexpression strings, e.g. '14**(32)'
     ( ... ) gets converted and appended to vars [with the parens included]
     ?^{ ... } gets converted and ? is replaced by ?^( ) and appended to vars
     Subexpression conversions are trigger by ')', '}', or any operator.
  */
  const p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;    // for eval test at end
  const theta=0;
  var js = '';          // output javascript expression
  var signcount = 0;    // number of minuses + twice number of pluses
  var digits = '';      // string of digits
  var vars = [];        // string of variables and subexpressions
  var unary = true;     // signs are unary
  var i,b,c;
  var recur = [];       // saved variables for recursion
  for (i=0; i < expr.length; i++) {
    c = expr[i];
    switch (c) {
    case '\\':
      c = expr.slice(i+1).match(/^\w*\s*/)[0];
      if (c.slice(0,4) != 'bmod') {
	throw new SyntaxError('Unknown token at '+i);
      }
      i += c.length;
      if (digits.length) {
	vars.push(digits);
      }
      if (!vars.length) {
	throw new SyntaxError('No dividend at '+i);
      }
      js += (signcount ? (signcount&1 ? '-' : '+') : '') +
	((vars.length > 1 || unary && signcount && vars[0].indexOf('**') >= 0) ?
	 '(' + vars.join('*') + ')' : vars[0]) + '%';
      signcount = 0;
      digits = '';
      vars = [];
      unary = true;
      break;

    case '{' :    // follows ^
      if (expr[i-1] != '^') {
	throw new SyntaxError('{ without preceding ^ at position '+i);
      }
      if (digits.length) {
	vars.push(digits);
      }
      if (vars.length) {
	b = vars.pop() + '**(';
      } else {
	throw new SyntaxError('Exponent without base at position '+i);
      }
      recur.push(
	{'c':c,'js':js,'signcount':signcount,'vars':vars,'unary':unary});
      js = b;
      signcount = 0;
      digits = '';
      vars = [];
      unary = true;
      break;
    case '(' :
      if (digits.length) {
	vars.push(digits);
      }
      recur.push(
	{'c':c,'js':js,'signcount':signcount,'vars':vars,'unary':unary});
      js = c;
      signcount = 0;
      digits = '';
      vars = [];
      unary = true;
      break;
    case ')' :    // terminates (
    case '}' :    // terminates ^
      if (!recur.length) {
	throw new SyntaxError('Unmatched '+c+' at position '+i);
      }
      if (digits.length) {
	vars.push(digits);
      }
      if (vars.length) {
	js += (signcount ? (signcount&1 ? '-' : '+') : '') +
	  ((vars.length > 1 || unary && signcount && vars[0].indexOf('**') >= 0) ?
	   '(' + vars.join('*') + ')' : vars[0]) + ')';
      } else {
	throw new SyntaxError('Empty exponent at position '+i);
      }
      b = recur.pop();
      vars = b.vars;
      unary = b.unary;
      vars.push(js);
      digits = '';
      signcount = b.signcount;
      js = b.js;
      b = b.c;
      if (!(b == '(' && c == ')' || b == '{' && c == '}')) {
	throw new SyntaxError('Unmatched '+c+' at position '+i);
      }
      break;
    case '+' :
      if (digits.length) {
	vars.push(digits);
      }
      if (vars.length) {
	js += (signcount ? (signcount&1 ? '-' : '+') : '') +
	  ((vars.length > 1 || unary && signcount && vars[0].indexOf('**') >= 0) ?
	   '(' + vars.join('*') + ')' : vars[0]);
	signcount = 2;
	digits = '';
	vars = [];
	unary = false;
      }
      break;
    case '-' :
      if (digits.length) {
	vars.push(digits);
      }
      if (vars.length) {
	js += (signcount ? (signcount&1 ? '-' : '+') : '') +
	  ((vars.length > 1 || unary && signcount && vars[0].indexOf('**') >= 0) ?
	   '(' + vars.join('*') + ')' : vars[0]);
	signcount = 1;
	digits = '';
	vars = [];
	unary = false;
      } else {
	signcount += 1;
      }
      break;
    case '\u00d7' :    //times
      if (digits.length) {
	vars.push(digits);
      }
      if (!vars.length) {
	throw new SyntaxError('No multiplicand at '+i);
      }
      js += (signcount ? (signcount&1 ? '-' : '+') : '') +
	((vars.length > 1 || unary && signcount && vars[0].indexOf('**') >= 0) ?
	 '(' + vars.join('*') + ')' : vars[0]) + '*';
      signcount = 0;
      digits = '';
      vars = [];
      unary = true;
      break;
    case '\u00f7' :    //divide
      if (digits.length) {
	vars.push(digits);
      }
      if (!vars.length) {
	throw new SyntaxError('No dividend at '+i);
      }
      js += (signcount ? (signcount&1 ? '-' : '+') : '') +
	((vars.length > 1 || unary && signcount && vars[0].indexOf('**') >= 0) ?
	 '(' + vars.join('*') + ')' : vars[0]) + '/';
      signcount = 0;
      digits = '';
      vars = [];
      unary = true;
      break;
    case '^' :
      if (expr[i+1] != '{') {
	throw new SyntaxError('Improper exponent at '+i);
      }
      break;
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      digits += c;
      break;
    case '.':
      if (digits.indexOf('.') >= 0) {
	throw new SyntaxError('Multiple decimal points');
      }
      digits += c;
      break;
    case '!':
      if (!digits.length || digits.indexOf('.') >= 0) {
	throw new SyntaxError('Illegal factorial');
      }
      vars.push('factorial('+digits+')');
      digits = '';
      break;
    case '\u03b8':
      c = 'theta';
    case '\u03c0':
      if (c.length == 1) c = 'pi';
    case '\u03c4':
      if (c.length == 1) c = 'tau';
    case 'e':
    case 'p': case 'q': case 'r': case 's': case 't':
    case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':
      if (digits.length) {
	vars.push(digits)
	digits = '';
      }
      vars.push(c);
      break;
    default :
      throw new SyntaxError('Unrecognized symbol');
    }
  }
  if (recur.length) {
    throw new SyntaxError('Premature termination of expression');
  }
  if (digits.length) {
    vars.push(digits);
  }
  if (vars.length) {
    js += (signcount ? (signcount&1 ? '-' : '+') : '') +
      ((vars.length > 1 || unary && signcount && vars[0].indexOf('**') >= 0) ?
       '(' + vars.join('*') + ')' : vars[0]);
  } else if (signcount) {
    throw new SyntaxError('illegitimate expression');
  }
  eval(js);    // might get syntax error
  return js;
}

function variables(expr) {    // return frequency of variables in expression
  var d = {};
  var i,c;
  const m = expr.match(/\w+/g);
  for (i in m) {
    c = m[i];
    if (c.length == 1 && 'p'<=c && c<='z' || c=='theta') {
      if (c in d) {
	d[c] += 1;
      } else {
	d[c] = 1;
      }
    }
  }
  return d;     
}

function length(o) {    // return length of object
  return Object.keys(o).length;
}

function fulleval(vin,obj) {    // evaluate variable v using dictionary o
  if (tvars[vin][vin] != undefined) {
    throw new Error('self-referential variable '+vin);
  }
  var win;
  for (win in vvars[vin]) {
    if (obj[win] == undefined) fulleval(win,obj);
  }
  for (win in obj) {
    eval('var '+win+'=obj[win];');
  }
  return (obj[vin]=eval(vv[vin]));
}

function updateLimits(event) {
  addplot(plottedvars);  
}

function plot() {    // plot expressions
  // automatically compute limits ?
  const b = document.getElementById('exprboxes').getElementsByClassName('down');
  var i;
  var vars = [];
  for (i=0; i<b.length; i++) {
    vars.push(b[i].previousElementSibling.id.slice(-1));
  }
  addplot(vars);
}

const side = 513;

function addplot(vars) {    // plot expressions with current limits
  plottedvars = vars.slice();
  var changed = false;
  const x0 = document.getElementById('lft').valueAsNumber;
  const x1 = document.getElementById('rgt').valueAsNumber;  
  const y0 = document.getElementById('bot').valueAsNumber;
  const y1 = document.getElementById('top').valueAsNumber;  
  var n,i,j,k;
  var v;
  var x;
  var y;
  var r,theta;
  var l;
  var changed = true;
  if (!(x0<x1 && y0<y1)) throw new Error('Low Limits Must Be Less Than High Limits');
  vvars = {};
  for (v in vv) {
    vvars[v] = variables(vv[v]);
    tvars[v] = Object.assign({},vvars[v]);
  }
  while (changed) {
    changed = false;
    for (v in vvars) {
      l = length(tvars[v]);
      for (w in tvars[v]) {
	Object.assign(tvars[v],tvars[w]);
      }
      changed |= l != length(tvars[v]);
    }
  }
  ctx.clearRect(0,0,side,side);
  ctx.strokeStyle='gray';
  if (x0 < 0 && 0 < x1) {
    ctx.beginPath();
    ctx.moveTo((1-side)*x0/(x1-x0),0);
    ctx.lineTo((1-side)*x0/(x1-x0),side);
    ctx.stroke();
  }
  if (y0 < 0 && 0 < y1) {
    ctx.beginPath();
    ctx.moveTo(0,(side-1)*y1/(y1-y0));
    ctx.lineTo(side,(side-1)*y1/(y1-y0));
    ctx.stroke();
  }
  ctx.strokeStyle='black';
  for (n in vars) {
    ctx.beginPath();
    if (tvars[vars[n]]['x']) {
      for (i = 0; i < side; i++) {
	x = x0 + i*(x1-x0)/(side-1);
	y = fulleval(vars[n],{'x':x});
	j = (side-1)*(y1-y)/(y1-y0);
	i ? ctx.lineTo(i,j) : ctx.moveTo(i,j);
      }
    } else if (tvars[vars[n]]['y']) {
      for (j = 0; j < side; j++) {
	y = y1 - j*(y1-y0)/(side-1);
	x = fulleval(vars[n],{'y':y});
	i = (side-1)*(x-x0)/(x1-x0);
	j ? ctx.lineTo(i,j) : ctx.moveTo(i,j);
      }
    } else if (tvars[vars[n]]['theta']) {
      for (k = 0; k < 361; k++) {
	theta = pi*k/180;
	r = fulleval(vars[n],{'theta':theta});
	x = r*Math.cos(theta);
	y = r*Math.sin(theta);
	i = (side-1)*(x-x0)/(x1-x0);
	j = (side-1)*(y1-y)/(y1-y0);
	k ? ctx.lineTo(i,j) : ctx.moveTo(i,j);
      }
    }
    ctx.stroke();
  }
}

function showpopup(o,s) {
  var b = document.body.getClientRects()[0];
  var r = o.parentNode.getClientRects()[0];
  o = document.getElementById(s);
  o.style.display='block';
  var q = o.getClientRects()[0];
  o.style.position = 'absolute';
  o.style.left = (r.width-q.width)/2+'px';
  o.style.top = (r.top+r.bottom-q.height)/2-b.top+'px';
}

function factorial(n) {
  if (n != Math.floor(n) || n < 0) {
    throw new RangeError('arg must be nonnegative integer');
  }
  if (n > 170) return Infinity;
  var x = 1;
  while (n) x*= n--;
  return x;
}		      

/* thoughts:
   Is there a way to do log?
   Graph of variable dependencies (must be tree ...
   ...  unless we want to solve simultaneous equations)
*/
/* idea for new scheme:
   boxes for constants, variables, numbers, operations; arrows for interaction
   ... converted to math expressions
   always one output, but possible multiple inputs, e.g. atan2, b^x, log_b x
   ... the last two defaulting b to e
   ... Sum and Product ?
*/
</script>
<style>
#debug {
  display:none;
}
button {
  margin:2px;
  font-size:18px;
}    
#mathbox {
  margin-bottom:2px;
}
#expression,#bs {display:inline;}
#exprdiv {
  overflow:hidden;
  white-space:nowrap;
  width:512px;
}
.var {
  font-family:serif;
  font-style:italic;
}
.varlabel {
  font-family:serif;
  font-style:italic;
  text-align:center;
  margin:0;
}
.popup {
  background-color:white;
  display:none;
  z-index:1;
  position:absolute;
  top:0;
  left:0;
  padding:6px;
  margin:6px;
  border:1px solid black;
  max-width:inherit;
}
#exprboxes {
  display:grid;
  grid-template-columns: 20px 440px 60px;
  row-gap:2px;
  align-items:center;
  margin-top:2px;
}
#exprboxes button {
  margin-left:4px;
  width:50px;
  font-size:12px;
}
.exprbox {
  display:flex;
  justify-content:center;
  align-items:center;
  width:440px;
  height:32px;
  border:1px solid black;
  padding:0;
  margin:0;
  text-align:center;
  overflow-x:auto;
  overflow-y:hidden;
}
.up {
  background-color:white;  
}
.down {
  background-color:pink;
}
#mathdiv {
  float:left;
}
#keyboard {
  display:inline;
  margin-left:20px;
  text-decoration:underline;
  cursor:context-menu;
}
#plot {
  float:left;
  display:grid;
  grid-template-columns: 20px 100px 313px 100px;
  grid-template-rows: 100px 313px 100px 20px;
  margin-left:10px;
}
input[type=number]::-webkit-outer-spin-button,
input[type=number]::-webkit-inner-spin-button {
  -webkit-appearance:none;
  margin:0;
}
input[type=number] {
  width:100px;
  height:20px;
  margin:0;
  box-sizing:border-box;
  -moz-appearance:textfield;
  appearance:textfield;
}
#top {
  grid-column-start:1;
  grid-row-start:1;
  transform:rotate(-90deg);
  transform-origin:50px 50px;
  text-align:right;
}
#bot {
  grid-column-start:1;
  grid-row-start:3;
  transform:rotate(-90deg);
  transform-origin:50px 50px;
  text-align:left;
}
#lft {
  grid-column-start:2;
  grid-row-start:4;
  text-align:left;
}
#rgt {
  grid-column-start:4;
  grid-row-start:4;
  text-align:right;
}
#canvas {
  grid-column-start:2;
  grid-column-end:span 3;
  grid-row-start:1;
  grid-row-end:span 3;
  width:513px;
  height:513px;
}
#x {
  grid-row-start:4;
  grid-column-start:3;
}
#y {
  grid-row-start:2;
  grid-column-start:1;
  align-self:center;
}
</style>
</head>
<body onload='init()'>
<div id='mathdiv'>
<div id='mathbox' class='exprbox'><p id='math' draggable='true'></p></div>
<div id='exprdiv'><p id='expression' contenteditable='plaintext-only'></p><br></div>
<div id='exprbuttons' tabindex='0'>
<button id='plus' class='op'>+</button>
<button id='minus' class='op'>&minus;</button>
<button id='times' class='op binary'>&times;</button>
<button id='divide' class='op binary'>&divide;</button>
<button id='mod' class='op binary'>%</button>
<button id='powup' class='op'>&uparrow;</button>
<button id='powdn' class='op closer'>&downarrow;</button>
<button id='oparen' class='op'>(</button>
<button id='cparen' class='op closer'>)</button>
<button id='bs'>Backspace</button>
<br>
<button class='var'>e</button>
<button class='var'>&pi;</button>
<button class='var'>&tau;</button>
<button class='digit'>0</button>
<button class='digit'>1</button>
<button class='digit'>2</button>
<button class='digit'>3</button>
<button class='digit'>4</button>
<button class='digit'>5</button>
<button class='digit'>6</button>
<button class='digit'>7</button>
<button class='digit'>8</button>
<button class='digit'>9</button>
<button id='decpt'>.</button>
<button id='bang'>!</button>
</br>
<button class='var'>&theta;</button>
<button class='var'>p</button>
<button class='var'>q</button>
<button class='var'>r</button>
<button class='var'>s</button>
<button class='var'>t</button>
<button class='var'>u</button>
<button class='var'>v</button>
<button class='var'>w</button>
<button class='var'>x</button>
<button class='var'>y</button>
<button class='var'>z</button>
<p id='keyboard' onclick="showpopup(this,'help')">Use keyboard</p>
</div>
<div id='exprboxes'>
<p class='varlabel'>p</p><div id='mathboxp' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>q</p><div id='mathboxq' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>r</p><div id='mathboxr' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>s</p><div id='mathboxs' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>t</p><div id='mathboxt' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>u</p><div id='mathboxu' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>v</p><div id='mathboxv' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>w</p><div id='mathboxw' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>x</p><div id='mathboxx' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>y</p><div id='mathboxy' class='exprbox'></div><button class='up'>PLOT</button>
<p class='varlabel'>z</p><div id='mathboxz' class='exprbox'></div><button class='up'>PLOT</button>
</div>
<p id='debug'></p>  
</div>
<!--Plotting
    We have a canvas for the plot
    To the left we have two input elements for upper and lower ordinate limits
    On the top we have two input elements for lower and upper abscissa limits
    The limits can be auto-set based on what is being plotted?
-->
<div id='plot'>
  <input id='top' class='lim' type='number'></input>
  <p id='y' class='varlabel'>y</p>
  <input id='bot' class='lim' type='number'></input>
  <canvas id='canvas'></canvas>
  <input id='lft' class='lim' type='number'></input>
  <p id='x' class='varlabel'>x</p>
  <input id='rgt' class='lim' type='number'></input>
  </div>
</div>
<div id='help' class='popup' onclick='this.style.display="none";document.getElementById("expression").focus();'>
<h2>Using the keyboard</h2>
<ul>
<li>Use asterisk ( * ) for multiply ( &times; )</li>
<li>Use slash ( / ) for divide ( &divide; )</li>
<li>Use hyphen ( - ) for minus ( &minus; )</li>
<li>Use caret ( ^ ) to start exponent ( &uparrow; )</li>
<li>Use backslash ( \\ ) to end exponent ( &downarrow; )</li>
<li>Use percent ( % ) for modulo ( mod )</li>
</ul>
<p>Grayed-out selections are ignored.</p>
<p>Click to hide this popup.</p>	       
</div>
</body>
</html>
<!--We enter mathematical expressions by clicking on components
    Simultaneously we parse the expression and keep the result separately
    We may need to reparse when we delete (using backspace or delete key)
    We can keep multiple expressions in an array, displaying all of them
    To plot expressions we may color code so more than one can appear together
    Plot may compute range and domain, or user may adjust with cursor or other command
    Current expression is selected by cursor for input or editing
    ) closes (, provided it's on the same exponent level
    v closes ^, provided there are no unclosed (s
    Only legitimate continuations of expression can be selected (others are grayed out)
    Selections:
    operators: + - x / ^ v ( ) (square?root??)
    variables: r s t u v w x y z (concatenation is multiplication)
    constants: 0 1 2 3 4 5 6 7 8 9 (concatenation is concatenation)
    commands: new? plot?     
    = ?
    apply op arg to both sides ?
    apply "first" operation (possibly of given kind?)
    keep stack of operations so can undo
    can we color operations that are doable?
    for polynomials (in one or more variables), gather?
    apply commute, distribute ?
-->
